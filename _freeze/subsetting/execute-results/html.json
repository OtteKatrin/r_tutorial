{
  "hash": "cd5a1dbc20f4bcb47d735c3be735ee7b",
  "result": {
    "markdown": "# Subsetting data\n\nPlease take a look at the different [data structures in R](data_structures.qmd) if you are not familiar with them, before you start with this chapter.\n\n## Data set\nLoad the data set, which lies within the folder `raw_data` in my working directory:\n\n::: {.cell}\n\n```{.r .cell-code}\nwinners <- readRDS(file = \"./raw_data/winners.rds\")\n```\n:::\n\n\nLet's take a quick look:\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(winners)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Category Year              Athlete    Nationality ID\n1      Men 1981 Dick Beardsley (Tie)  United States  1\n2      Men 1981  Inge Simonsen (Tie)         Norway NA\n3      Men 1982           Hugh Jones United Kingdom  3\n4      Men 1983         Mike Gratton United Kingdom  4\n5      Men 1984     Charlie Spedding United Kingdom  5\n6      Men 1985          Steve Jones United Kingdom  6\n```\n:::\n:::\n\nSo, this data frame seems to hold the winners of the london marathon, but their finishing times are missing. They are stored in another data set, but we will deal with that later.\nFor now we want to look at how we can extract data from our data structures, so we can work with it.\n\n\n## Data frames\n\nWe will look at two ways to extract rows by conditions from data frames.\n\n### Base R\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define an example data frame\npersons <- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n```\n:::\n\nIn `Base R`, extracting rows or columns from a data frame is very similar to extracting values from a vector. \nWe use square brackets `[,]`, but this time with a `,` in the middle. \nIn front of the `,` we write the **rows** we want to extract:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the first and the fourth row\npersons[c(1, 4), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n```\n:::\n:::\n\n\nBehind it the **columns**:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the second and the fourth column:\npersons[, c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n```\n:::\n\n```{.r .cell-code}\n# Extract the columns by name:\npersons[, c(\"age\", \"big5_extro\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n```\n:::\n\n```{.r .cell-code}\n# Or only the column age (and turn it intow a vector right away):\npersons$age\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19 17 18 18\n```\n:::\n:::\n\n\nAnd of course we can combine both calls:\n\n::: {.cell}\n\n```{.r .cell-code}\npersons[c(1, 4), c(2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age big5_extro\n1  19        3.5\n4  18        4.2\n```\n:::\n\n```{.r .cell-code}\npersons[c(1, 4), c(\"age\", \"big5_extro\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  age big5_extro\n1  19        3.5\n4  18        4.2\n```\n:::\n:::\n\n\nWe can also use boolean values:\n\n::: {.cell}\n\n```{.r .cell-code}\npersons[c(TRUE, FALSE, FALSE, TRUE), c(TRUE, FALSE, FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name big5_extro\n1  Anna        3.5\n4 Jessi        4.2\n```\n:::\n:::\n\n\nNow the stuff we looked at in [logical operators](https://nickhaf.github.io/r_tutorial/basics.html#comparisons-and-logical-operators) comes in handy! We can now filter rows which match some condition. For example, we might want to look at all persons which are `18` years old:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons[persons$age == 18, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n```\n:::\n:::\n\nTake a close look at the comparison before the `,`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons$age == 18\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE\n```\n:::\n:::\n\n`persons$age` is a vector, so comparing its values to a specified value yields a logical vector with the respective `TRUE` and `FALSE` values. We can insert this logical vector in front of the `,` to extract all rows corresponding to that condition. \n\nWe can also combine multiple logical vectors using `&` (\"and\") and `|` (\"or\").\nFor example, we might want to look at all persons older than 17 which have an extroversion rating below 4.5:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons[persons$age > 17 & persons$big5_extro < 4.5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n```\n:::\n:::\n\n\nOr at all persons, that are either `18` years old, or have an extroversion rating above `3`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons[persons$age == 18 | persons$big5_extro > 3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n```\n:::\n:::\n\n\nIn the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Enter, the `filter()` function:\n\n### Tidyverse\nThe `dplyr` package is part of the `tidyverse` and provides a grammar of data manipulation. \nWe can use `filter()` to subset rows from a data frame:\n\n::: tidy\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nfilter(persons, age == 18, big5_extro < 4.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n```\n:::\n:::\n\n:::\n\nNote how we can just write our conditions without connecting them with `&` (`filter()` does that automatically for us).\nAlso, we don't have to put the column names into `\"\"`, because `filter()` knows that this are column names of the `persons` data frame, which makes coding a bit more pleasant.\n\n#### Remarks: the pipe operator\nHold on! Normally, we wouldn't write `tidyverse` code like that. Instead, we would use the pipe operator `%>%` (*than do*), which makes it easy to connect multiple function calls:\n\n::: {.cell}\n\n```{.r .cell-code}\npersons %>%\n  filter(age == 18, big5_extro < 4.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n```\n:::\n:::\n\nHere, we first input the data frame we want to manipulate. Than we filter, as specified by the pipe operator. \nLike this, we can easily connect multiple function calls instead of nesting them within multiple brackets, which increases the readability massively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_value <- -8\nsqrt(mean(abs((rep(seq(from = start_value, to = 20, by = 0.5), 4)))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.895853\n```\n:::\n:::\n\n\nbecomes:\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_value <- -8\nstart_value %>%\n  seq(from = ., to = 20, by = 0.5) %>%\n  rep(times = 4) %>%\n  abs %>%\n  mean %>%\n  sqrt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.895853\n```\n:::\n:::\n\n\nMuch nicer to read, right?\nSome notes on this syntax: If we don't have any additonal arguments we want to put into the function, we can just write the function name without any brackets. The pipe operator will give the result of the last function as input into the next function. If we want to clearly state which of the function arguments should receive the input, we can write a `.`, which can be read as *output of the previous function call*. \n\n\n## Vectors\n\nExtracting elements from vectors is pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_char <- c(\"Jess\", \"Jane\", \"Joe\", \"Alex\")\nvec_char[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jane\"\n```\n:::\n:::\n\n\nOf course we can also do that for multiple elements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_char[c(2,3,4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jane\" \"Joe\"  \"Alex\"\n```\n:::\n\n```{.r .cell-code}\n## Or, less to write:\nvec_char[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jane\" \"Joe\"  \"Alex\"\n```\n:::\n:::\n\n\nAnother way would be to provide a logical vector, which defines for each position, if we want to extract the element or not:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_char[c(TRUE, FALSE, TRUE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Jess\" \"Joe\" \n```\n:::\n:::\n\n\nThis will come in handy later on, when we want to extract rows from data frames by different conditions. \nIf you feel like you need to, you can refresh on [logical operators](https://nickhaf.github.io/r_tutorial/basics.html#comparisons-and-logical-operators) before continuing. \n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}