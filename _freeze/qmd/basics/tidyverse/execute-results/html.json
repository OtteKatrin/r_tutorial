{
  "hash": "e087b1d27e4797a06e8e8c4b7d745816",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse\"\n---\n\n\nThe `tidyverse` is a collection of packages following a common philosophy, and facilitate many aspects of coding in R, for example data wrangling and plotting. It is not necessary to learn the `tidyverse` syntax, it differs a bit from the standard R syntax. However, I find it easier to understand in many cases, so I will provide the syntax from the respective `tidyverse` package along with the `Base R` syntax in most cases.\n\n::: tidy\nTidyverse syntax will be marked like this.\n:::\n\n\n## The pipe operator\n`tidyverse` code is often written using the pipe operator `%>%` (*than do*), which makes it easy to connect multiple function calls:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(seq(from = 1, to = mean(c(45:100), na.rm = TRUE), by = 0.1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26313\n```\n:::\n:::\n\n\nIs the same as: \n\n::: tidy\n\n::: {.cell output.lines='4'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nc(45:100) %>%\n  mean(na.rm = TRUE) %>%\n  seq(from = 1, to = ., by = 0.1) %>%\n  sum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 26313\n```\n:::\n:::\n\n:::\n\nMuch nicer to read, right?\n\nSome notes on this syntax: \n1. If we don't have any additional arguments we want to put into the function, we can just write the function name without any brackets, like we do at the end with `sum`.\n1. The pipe operator will give the result of the last function as input into the next function. That's why we don't have to specify the vector within the `mean()` function. \n1. If we want to clearly state which of the function arguments should receive the input, we can write a `.`, which can be read as *output of the previous function call*. That's what we do in the `seq()` function. It calculates a sequence from `1` to the mean of `c(45:100)`. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}