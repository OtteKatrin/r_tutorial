{
  "hash": "2c864baefac7fc58d4593f3a4253f714",
  "result": {
    "markdown": "# Data structures\n\nThere are five main data structures in R which differ on their dimensions (one dimension, two dimensions, n dimensions) and the type of the elements they are containing (same type, different types):[^data_structures-1]\n\n[^data_structures-1]: Table from [Advanced R](http://adv-r.had.co.nz/Data-structures.html).\n\n\n::: {.cell-output-display}\n|   |Homogeneous   |Heterogeneous |\n|:--|:-------------|:-------------|\n|1d |atomic vector |list          |\n|2d |matrix        |data.frame    |\n|nd |array         |              |\n:::\n\n\nLet's take a closer look at the two we will use mostly throughout this workshop:\n\n## Vector\n\nAtomic vectors (from hereon only called vectors) contain elements of only the same type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_vec <- c(2023, 8, 8)\nnum_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2023    8    8\n```\n:::\n\n```{.r .cell-code}\nchar_vec <- c(\"This\", \"is\", \"a\", \"vec\", \".\")\nchar_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This\" \"is\"   \"a\"    \"vec\"  \".\"   \n```\n:::\n\n```{.r .cell-code}\nlog_vec <- c(TRUE, FALSE)\nlog_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE\n```\n:::\n:::\n\n\nThe `c()` stands for combine, or concatenate, and is the basic function for building a vector out of single elements.\n\n### Remarks: Data types\n\nIf we take a look at the structure of the vectors we have just created, we see se a short description of the data type we are dealing with in front of the vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(num_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 2023 8 8\n```\n:::\n\n```{.r .cell-code}\nstr(char_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:5] \"This\" \"is\" \"a\" \"vec\" \".\"\n```\n:::\n\n```{.r .cell-code}\nstr(log_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n logi [1:2] TRUE FALSE\n```\n:::\n:::\n\n\nThe first one is `num` (numeric) so it only stores numeric values. The second one is `char` (character), so it only can contain strings. And last but not least we have `logi` (logical) for [boolean values](basics.qmd#comparisons-and-logical-operators). Why is that important? Well, some functions only make sense for specific data types. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(char_vec)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(char_vec): argument is not numeric or logical:\nreturning NA\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\ngives us a warning, because the input has the wrong format.\n\n## Data frame\n\nA data frame is two dimensional and can store elements of different types. It is the closest to data tables we are probably most used to working with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons <- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n```\n:::\n\n\nNote that we do nothing else here than combining vectors to a data frame. Each vector will be one column.\n\n### Tibbles\n\nA special type of data frames are the so called `tibbles`. Tibbles are a modern version of data frames and the standard data frame type of the `tidyverse`, as they have some advantageous characteristics (e.g., note the prettier printing of the data frame). So don't be confused if you run into them, in general they behave like data frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersons_tibble <- tibble::tibble(\n  name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n  age = c(19, 17, 18, 18),\n  birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n  big5_extro = c(3.5, 2, 4.5, 4.2)\n)\npersons_tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 4\n  name    age birth_month big5_extro\n  <chr> <dbl> <chr>            <dbl>\n1 Anna     19 Jan                3.5\n2 Alex     17 Sep                2  \n3 John     18 Oct                4.5\n4 Jessi    18 Mar                4.2\n```\n:::\n:::\n\n\n## Honorable mention: List\n\nA list is a one dimensional object, which can, unlike like a vector, contain elements of different types, but also of different lengths. For example, we can store a vectors of different lengths and data frames in a list, which makes it the most versatile data structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonality_rating <- list(\n     big5 = data.frame(name = c(\"Jessi\", \"John\"),\n                       extraversion = c(4.3, 2), \n                       openness = c(3.8, NA)),\n     rating_type = \"self_rating\"\n     )\npersonality_rating\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$big5\n   name extraversion openness\n1 Jessi          4.3      3.8\n2  John          2.0       NA\n\n$rating_type\n[1] \"self_rating\"\n```\n:::\n:::\n\n\nHere, we define the list `personality_rating`, which includes a data frame with the personality rating, and some meta information in the form of a character vector, describing the rating type. We won't use it any more in this workshop, but keep in mind it exists, as it quickly becomes necessary for managing more complex tasks.\n\nInstead, we are now well equipped to get started with some data manipulation and transformation.\n\n# Getting an overview\n\nTo take a look at these data structures, we can use different commands. One of the most important ones might be `View()`, which will open the data set excel-style in a new window:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(persons)\n```\n:::\n\n\nEspecially for bigger data sets, it might be more feasible to only look at the structure and not the whole data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(persons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t4 obs. of  4 variables:\n $ name       : chr  \"Anna\" \"Alex\" \"John\" \"Jessi\"\n $ age        : num  19 17 18 18\n $ birth_month: chr  \"Jan\" \"Sep\" \"Oct\" \"Mar\"\n $ big5_extro : num  3.5 2 4.5 4.2\n```\n:::\n:::\n\n\nOn the left side we have the column names of this data frame, followed by the [type]() of the column.\n\nTo get an overview of the statistical properties of all columns and their missing values, we can use `summary()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(persons)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name                age        birth_month          big5_extro   \n Length:4           Min.   :17.00   Length:4           Min.   :2.000  \n Class :character   1st Qu.:17.75   Class :character   1st Qu.:3.125  \n Mode  :character   Median :18.00   Mode  :character   Median :3.850  \n                    Mean   :18.00                      Mean   :3.550  \n                    3rd Qu.:18.25                      3rd Qu.:4.275  \n                    Max.   :19.00                      Max.   :4.500  \n```\n:::\n:::\n\nHere we can see the mean, minimum and maximum values and more for the numeric columns. \n\n# Exercises\n\n1.  Load the `tutoR` package and start the exercises about `data structures` by typing the following code into you console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlearnr::run_tutorial(name = \"data_structures\", package = \"tutoR\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}