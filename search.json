[
  {
    "objectID": "load_data.html",
    "href": "load_data.html",
    "title": "Load data",
    "section": "",
    "text": "There are many different data types out there, of which many can be loaded into R. Depending on the type, different commands are used within R. Sometimes, we will have to use additional packages to get access to that function, mainly readxl and haven.\n\n\n\n\n\n\n\n\n\nData.type\nImport\nExport\n\n\n\n\nR objects (.Rdata, .rda)\nload()\nsave()\n\n\nsingle R object (.Rds)\nreadRDS()\nsaveRDS()\n\n\ntext-files (.txt)\nread.table()\nwrite.table()\n\n\n.csv-files (.csv)\nread.csv()\nwrite.csv()\n\n\nExcel-files (.xlsx)\nreadxl::read_excel()\nwritexl::write_xlsx()\n\n\nSPSS-files (.sav)\nhaven::read_sav()\nhaven::write_sav()\n\n\nSAS-files (.sas)\nhaven::read_sas()\nhaven::write_sas()\n\n\nStata-files (.stata)\nhaven::read_dta()\nhaven::write_dta()\n\n\n\n\n\n\n\nYou can head to a specific file by using the full path (absolute path): \"C:\\Users\\hafiznij\\Documents\\GitHub\\r_tutorial\\raw_data\\winners.rda\". This approach has some disadvantages: it will only work on my notebook. If i want to continue my project on another device, i will have to change the path. The same goes for other people who want to work with my project. So, to keep these paths more reproducable, we should always use relative paths if possible: \".\\raw_data\\winners.rda\". This will always work independently of the device i am working on, as long as i am in the correct working directory.\nThe working directory is the path R is currently working in. I can obtain it by typing:\n\ngetwd()\n\n[1] \"/home/runner/work/r_tutorial/r_tutorial\"\n\n\nLuckily, as long as we work with RStudio projects, we don’t have to deal with that, as the working directory is set automatically by the project.\nNow take a look at the working directory and the relative path i used for loading the winners.rda. Notice something? Correct, both paths combined equal the absolute path to the file. So by splitting it up, we obtain a more reproducible path, that works independent of where the current working directory is."
  },
  {
    "objectID": "load_data.html#data-types",
    "href": "load_data.html#data-types",
    "title": "Load data",
    "section": "",
    "text": "There are many different data types out there, of which many can be loaded into R. Depending on the type, different commands are used within R. Sometimes, we will have to use additional packages to get access to that function, mainly readxl and haven.\n\n\n\n\n\n\n\n\n\nData.type\nImport\nExport\n\n\n\n\nR objects (.Rdata, .rda)\nload()\nsave()\n\n\nsingle R object (.Rds)\nreadRDS()\nsaveRDS()\n\n\ntext-files (.txt)\nread.table()\nwrite.table()\n\n\n.csv-files (.csv)\nread.csv()\nwrite.csv()\n\n\nExcel-files (.xlsx)\nreadxl::read_excel()\nwritexl::write_xlsx()\n\n\nSPSS-files (.sav)\nhaven::read_sav()\nhaven::write_sav()\n\n\nSAS-files (.sas)\nhaven::read_sas()\nhaven::write_sas()\n\n\nStata-files (.stata)\nhaven::read_dta()\nhaven::write_dta()"
  },
  {
    "objectID": "load_data.html#absolute-paths-vs.-relative-paths",
    "href": "load_data.html#absolute-paths-vs.-relative-paths",
    "title": "Load data",
    "section": "",
    "text": "You can head to a specific file by using the full path (absolute path): \"C:\\Users\\hafiznij\\Documents\\GitHub\\r_tutorial\\raw_data\\winners.rda\". This approach has some disadvantages: it will only work on my notebook. If i want to continue my project on another device, i will have to change the path. The same goes for other people who want to work with my project. So, to keep these paths more reproducable, we should always use relative paths if possible: \".\\raw_data\\winners.rda\". This will always work independently of the device i am working on, as long as i am in the correct working directory.\nThe working directory is the path R is currently working in. I can obtain it by typing:\n\ngetwd()\n\n[1] \"/home/runner/work/r_tutorial/r_tutorial\"\n\n\nLuckily, as long as we work with RStudio projects, we don’t have to deal with that, as the working directory is set automatically by the project.\nNow take a look at the working directory and the relative path i used for loading the winners.rda. Notice something? Correct, both paths combined equal the absolute path to the file. So by splitting it up, we obtain a more reproducible path, that works independent of where the current working directory is."
  },
  {
    "objectID": "packages.html",
    "href": "packages.html",
    "title": "Packages",
    "section": "",
    "text": "Packages are extensions to the base R you get by default. Most times they provide many new functions, bundled around a specific use case. When working with R you will have to rely heavily on packages developed by others. There are many, many great packages out there facilitating your work with R and making possible many different analyses, visualizations and many more.\nWe can compare them somewhat to apps in an appstore:\n1 First, we have to install the package: install.packages(\"packagename\"). - Most of the openly available packages lie on CRAN (Comprehensive R Archive Network). But you can also download packages form other sources, for example GitHub. This is what you did when downloading the tutoR package in About this workshop.\n2 Then, we have to load them in each session where we want to use them (like tipping on the app icon): library(packagename).\n\nNote that in install.packages(\"packagename\") we have to put the package into quotation marks, when calling library(packagename) not.\n\n\n\nBefore we can use packages we have to install them once. Most packages are hosted via the Comprehensive R Archive Network (CRAN), to install a package from there, we can use:\n\ninstall.packages(\"aRtsy\")\n\nBut often packages are only (or as well) provided via GitHub. To install a package from there, use:\n\ndevtools::install_github(\"cutterkom/generativeart\")\n\n\n\n\nAfter installing a package, we have to load it into our R session:\n\n#library(aRtsy)\n\nNow we are free to use it, in this case to generate some artwork:\n\n#set.seed(1)\n#canvas_collatz(colors = colorPalette(\"lava\"))\n\n\n\n\nOf course it can happen that different packages include functions with the same name. For example, look at the warnings we get when installing and then loading the packages ggplot2 and psych:\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"psych\")\n\n\nlibrary(ggplot2)\nlibrary(psych)\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n\n\nThere seems to be a function named alpha which is included in both packages (but not the same function, just the same name). The warning message notifies us that the object alpha from ggplot2 is masked, so if we call it, the alpha function from the psych package is used. To solve that quandary, we can use the :: operator. In front we write the package name, and behind it the name of the function we want to use from that package:\n\nggplot2::alpha()\npsych::alpha()\n\n\n\n\nFinally, a quick note on package management and reproducability of your code. R versions and package versions will change over time, in which case also the output of your code might change. Therefore, it is good practice to save the R version and package versions, so your code stays (kind of) reproducable for a longer period of time. The most straight forward thing to do is to just write down your R-version and the package versions at the top of your script. Call the versions you use with:\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] psych_2.3.6   ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       nlme_3.1-162      cli_3.6.1         knitr_1.43       \n [5] rlang_1.1.1       xfun_0.39         generics_0.1.3    renv_1.0.0       \n [9] jsonlite_1.8.7    glue_1.6.2        colorspace_2.1-0  htmltools_0.5.5  \n[13] scales_1.2.1      fansi_1.0.4       rmarkdown_2.23    grid_4.3.1       \n[17] evaluate_0.21     munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1    \n[21] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    dplyr_1.1.2      \n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 lattice_0.21-8    digest_0.6.32    \n[29] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        parallel_4.3.1   \n[33] mnormt_2.1.1      pillar_1.9.0      magrittr_2.0.3    withr_2.5.0      \n[37] tools_4.3.1       gtable_0.3.3     \n\n\nA more elegant approach to manage your packages is to use a dedicated package like renv, which will make it a lot easier to manage your package versions. But this is past the scope of this workshop, just keep in mind it might be something rewarding to look at, if you should start to programm more with R. Instead, let’s look at how to get data into R in the next chapter, so we can actually get to work with it."
  },
  {
    "objectID": "packages.html#install-packages",
    "href": "packages.html#install-packages",
    "title": "Packages",
    "section": "",
    "text": "Before we can use packages we have to install them once. Most packages are hosted via the Comprehensive R Archive Network (CRAN), to install a package from there, we can use:\n\ninstall.packages(\"aRtsy\")\n\nBut often packages are only (or as well) provided via GitHub. To install a package from there, use:\n\ndevtools::install_github(\"cutterkom/generativeart\")"
  },
  {
    "objectID": "packages.html#load-packages",
    "href": "packages.html#load-packages",
    "title": "Packages",
    "section": "",
    "text": "After installing a package, we have to load it into our R session:\n\n#library(aRtsy)\n\nNow we are free to use it, in this case to generate some artwork:\n\n#set.seed(1)\n#canvas_collatz(colors = colorPalette(\"lava\"))"
  },
  {
    "objectID": "packages.html#conflicts",
    "href": "packages.html#conflicts",
    "title": "Packages",
    "section": "",
    "text": "Of course it can happen that different packages include functions with the same name. For example, look at the warnings we get when installing and then loading the packages ggplot2 and psych:\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"psych\")\n\n\nlibrary(ggplot2)\nlibrary(psych)\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n\n\nThere seems to be a function named alpha which is included in both packages (but not the same function, just the same name). The warning message notifies us that the object alpha from ggplot2 is masked, so if we call it, the alpha function from the psych package is used. To solve that quandary, we can use the :: operator. In front we write the package name, and behind it the name of the function we want to use from that package:\n\nggplot2::alpha()\npsych::alpha()"
  },
  {
    "objectID": "packages.html#deliberate-package-management",
    "href": "packages.html#deliberate-package-management",
    "title": "Packages",
    "section": "",
    "text": "Finally, a quick note on package management and reproducability of your code. R versions and package versions will change over time, in which case also the output of your code might change. Therefore, it is good practice to save the R version and package versions, so your code stays (kind of) reproducable for a longer period of time. The most straight forward thing to do is to just write down your R-version and the package versions at the top of your script. Call the versions you use with:\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] psych_2.3.6   ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       nlme_3.1-162      cli_3.6.1         knitr_1.43       \n [5] rlang_1.1.1       xfun_0.39         generics_0.1.3    renv_1.0.0       \n [9] jsonlite_1.8.7    glue_1.6.2        colorspace_2.1-0  htmltools_0.5.5  \n[13] scales_1.2.1      fansi_1.0.4       rmarkdown_2.23    grid_4.3.1       \n[17] evaluate_0.21     munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1    \n[21] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    dplyr_1.1.2      \n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 lattice_0.21-8    digest_0.6.32    \n[29] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        parallel_4.3.1   \n[33] mnormt_2.1.1      pillar_1.9.0      magrittr_2.0.3    withr_2.5.0      \n[37] tools_4.3.1       gtable_0.3.3     \n\n\nA more elegant approach to manage your packages is to use a dedicated package like renv, which will make it a lot easier to manage your package versions. But this is past the scope of this workshop, just keep in mind it might be something rewarding to look at, if you should start to programm more with R. Instead, let’s look at how to get data into R in the next chapter, so we can actually get to work with it."
  },
  {
    "objectID": "packages.html#footnotes",
    "href": "packages.html#footnotes",
    "title": "Packages",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIcons from icons8.de.↩︎\nIcons from icons8.de.↩︎"
  },
  {
    "objectID": "Manipulation.html",
    "href": "Manipulation.html",
    "title": "New variables",
    "section": "",
    "text": "New variables\n\n\nifelse\n\n\nmissings"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Workshop",
    "section": "",
    "text": "The following tutorial will teach you the basics of R. It is designed to be self paced, so you can work in you own tempo.\n\n\n\nLearn the basics of programming in R as needed for the rest of the Open Research Summer School."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "R Workshop",
    "section": "",
    "text": "The following tutorial will teach you the basics of R. It is designed to be self paced, so you can work in you own tempo.\n\n\n\nLearn the basics of programming in R as needed for the rest of the Open Research Summer School."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Basic operations",
    "section": "",
    "text": "Let’s take a quick look at the most important basic operations in R.\n\n\nWe can use R as a calculator:\n\n(1 + 2) * 3^2\n2 - 3/log(8)\n\n\n\n\nWe can create objects in R by using the assignment operator &lt;-, which assigns a value to an object:\n\n## Assign the result of 1 + 1 to the object 'result':\nresult &lt;- 1 + 1\nresult\n\n[1] 2\n\n## Assign the result of the comparison to the object 'log_result':\nlog_result &lt;- !(10 &gt; 1)\nlog_result\n\n[1] FALSE\n\n\n\n\n\nThe boolean variables in R are TRUE and FALSE. Comparison operators return either TRUE or FALSE:\n\n1 &lt; 2\n\n[1] TRUE\n\n# But:\n2 &lt; 1\n\n[1] FALSE\n\n\nThese are the comparison operators you will typically use:\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n==\nequal to\n\n\n!=\nnot equal to\n\n\n&lt;=\nless or equal\n\n\n&gt;=\ngreater or equal\n\n\n\n\n\nMainly we will use these logical operation to check which elements in a vector satisfy some requirements:\n\n# Build a vector of numbers ranging from 1 to 10\nvec_num &lt;- 1:10\n\n# Check which of these numbers are smaller than 5\nvec_num &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nThis will become important later on, when we want to subset vectors and data frames to extract only those values that satisfy some requirements we defined.\n\n\n\nWe can invert boolean values by using !:\n\n!TRUE\n\n[1] FALSE\n\n!(1 &gt; 100)\n\n[1] TRUE\n\n!(1:10 != c(1, 2))\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n\nEverything that does something in R is a function. A function call has the form: functionname(argument1 = value, argument2 = value, ...). One basic example for a function is the function that can calculate the square root:\n\nsqrt(4)\n\n[1] 2\n\n\nWe can also assign the name of the function argument to our value. This is clearer, as we don’t rely on the order of the function arguments:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nwill rep 4 10 times. If we swap the arguments, the 10 will be repeat 4 times:\n\nrep(10, 4)\n\n[1] 10 10 10 10\n\n\nBut if we specify which value belongs to which function argument, the order doesn’t matter:\n\nrep(times = 10, x = 4)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nHow do we know which arguments a function has?:\n\n\n\nOne of the most important functions in R is the help-function ?:\n\n?rep\n\nwill open the documentation for the function with the description of its usage, details about the arguments … In the next chapter we will take a very quick look at R’s data types.\n\n\n\n\nLoad the tutoR package and start the exercises about the basic operations by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"basics\", package = \"tutoR\")"
  },
  {
    "objectID": "basics.html#basic-mathematical-operations",
    "href": "basics.html#basic-mathematical-operations",
    "title": "Basic operations",
    "section": "",
    "text": "We can use R as a calculator:\n\n(1 + 2) * 3^2\n2 - 3/log(8)"
  },
  {
    "objectID": "basics.html#assignment-operator",
    "href": "basics.html#assignment-operator",
    "title": "Basic operations",
    "section": "",
    "text": "We can create objects in R by using the assignment operator &lt;-, which assigns a value to an object:\n\n## Assign the result of 1 + 1 to the object 'result':\nresult &lt;- 1 + 1\nresult\n\n[1] 2\n\n## Assign the result of the comparison to the object 'log_result':\nlog_result &lt;- !(10 &gt; 1)\nlog_result\n\n[1] FALSE"
  },
  {
    "objectID": "basics.html#comparisons-and-logical-operators",
    "href": "basics.html#comparisons-and-logical-operators",
    "title": "Basic operations",
    "section": "",
    "text": "The boolean variables in R are TRUE and FALSE. Comparison operators return either TRUE or FALSE:\n\n1 &lt; 2\n\n[1] TRUE\n\n# But:\n2 &lt; 1\n\n[1] FALSE\n\n\nThese are the comparison operators you will typically use:\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n==\nequal to\n\n\n!=\nnot equal to\n\n\n&lt;=\nless or equal\n\n\n&gt;=\ngreater or equal\n\n\n\n\n\nMainly we will use these logical operation to check which elements in a vector satisfy some requirements:\n\n# Build a vector of numbers ranging from 1 to 10\nvec_num &lt;- 1:10\n\n# Check which of these numbers are smaller than 5\nvec_num &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nThis will become important later on, when we want to subset vectors and data frames to extract only those values that satisfy some requirements we defined."
  },
  {
    "objectID": "basics.html#section",
    "href": "basics.html#section",
    "title": "Basic operations",
    "section": "",
    "text": "We can invert boolean values by using !:\n\n!TRUE\n\n[1] FALSE\n\n!(1 &gt; 100)\n\n[1] TRUE\n\n!(1:10 != c(1, 2))\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "basics.html#functions",
    "href": "basics.html#functions",
    "title": "Basic operations",
    "section": "",
    "text": "Everything that does something in R is a function. A function call has the form: functionname(argument1 = value, argument2 = value, ...). One basic example for a function is the function that can calculate the square root:\n\nsqrt(4)\n\n[1] 2\n\n\nWe can also assign the name of the function argument to our value. This is clearer, as we don’t rely on the order of the function arguments:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nwill rep 4 10 times. If we swap the arguments, the 10 will be repeat 4 times:\n\nrep(10, 4)\n\n[1] 10 10 10 10\n\n\nBut if we specify which value belongs to which function argument, the order doesn’t matter:\n\nrep(times = 10, x = 4)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nHow do we know which arguments a function has?:"
  },
  {
    "objectID": "basics.html#help",
    "href": "basics.html#help",
    "title": "Basic operations",
    "section": "",
    "text": "One of the most important functions in R is the help-function ?:\n\n?rep\n\nwill open the documentation for the function with the description of its usage, details about the arguments … In the next chapter we will take a very quick look at R’s data types."
  },
  {
    "objectID": "basics.html#exercise",
    "href": "basics.html#exercise",
    "title": "Basic operations",
    "section": "",
    "text": "Load the tutoR package and start the exercises about the basic operations by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"basics\", package = \"tutoR\")"
  },
  {
    "objectID": "the_big_picture.html",
    "href": "the_big_picture.html",
    "title": "The big picture",
    "section": "",
    "text": "Now that we have completed our set up, let’s dive right into programming with R. In this chapter, we will go through a “mini-project”, which follows a typical workflow when working with data in R. We will install and load packages, load data, perform some operations on this data, calculate some summary statistics and plot them. In later chapters, we will go into a little bit more depth for each topic. If you want to have more in depth information instead of following the whole workflow first, you can also skip this chapter and jump to the chapters and exercises you are interested in. But make sure to do the final exercise, to test you R proficiency in the end.\n\n\nPackages are extensions to the base R you get by default. We already installed our first packages in About this workshop. Let’s keep doing that and install the following package as well:\n\ninstall.packages(\"tidyverse\")\n\nThe tidyverse is a collection of packages following a common philosophy, and facilitate many aspects of coding in R, for example data wrangling and plotting. We will use both functions from base R and from the tidyverse.\nJust by installing the packages, we can’t use them. We also have to load them into our R session:\n\nlibrary(tutoR)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe top of your R Script should look something like this:\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"nickhaf/tutoR\")\ninstall.packages(\"tidyverse\")\n\nlibrary(tutoR)\nlibrary(tidyverse)\n\n\n\n\nData is loaded into R so you can work with it. Let’s do just that. First, you need to download the file “winners.rds” from this link and save it in your project folder (Tip: Save it in a new subfolder named “raw_data” or somewhat similar.). The data comes from the LondonMarathon package. Next, take a look at the ending. Different data formats need different functions for loading them into R. The winners.rds file has the ending .rds. So we use readRDS to load it into R. Here you can find a more thourough discussion about loading different data formats.\n\nwinners &lt;- readRDS(file = \"./raw_data/winners.rds\")\n\nThis will load the data into R and assigning it the name winners by using the &lt;-. You can see the data popping up in your Environment pane on the upper right. It is important you use the correct path, because otherwise R will not find your data file. Here the RStudio project we have created earlier comes in handy. It automatically knows our file lies within our project folder, which is why we can use a relative path, that starts at the project path and looks into the folder raw_data to open the file. Otherwise, we would have to use an absolute path (like “C:/Users/hafiznij/Documents/GitHub/r_tutorial/raw_data/london_marathon.rda” which will only work on my notebook, and only if my project stays in on this path.\n\n\n\nNow that we have our data loaded safely into R, we can get an overview with a multitude of commands. One of the most important ones might be View(), which will open the data set excel-style in a new window:\n\nView(winners)\n\nEspecially for bigger data sets, it might be more feasible to only look at the structure and not the whole data set:\n\nstr(winners)\n\ntibble [165 × 5] (S3: tbl_df/tbl/data.frame)\n $ Category   : chr [1:165] \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Year       : num [1:165] 1981 1981 1982 1983 1984 ...\n $ Athlete    : chr [1:165] \"Dick Beardsley (Tie)\" \"Inge Simonsen (Tie)\" \"Hugh Jones\" \"Mike Gratton\" ...\n $ Nationality: chr [1:165] \"United States\" \"Norway\" \"United Kingdom\" \"United Kingdom\" ...\n $ ID         : int [1:165] 1 NA 3 4 5 6 7 8 9 10 ...\n\n\nOn the left we can see the columns of this data.frame, named Category, Year, Athlete, Nationality and ID. On the right we see the first values in each column, for example 1981, 1981, 1982 etc … in the Year-column.\n\n\n\nNow, lets do something with this data. We want to answer the question if people have gotten faster at running marathons over that last 40 years. Sadly, the finishing times are not saved in this data set, but in another one named times.rda. So we need a way to combine them both, so we can run our analysis on the data.\nExercise: Download the second data set called “times.rda” and load it into R on your own.\n\n\nLet’s take a quick look at that one as well:\n\nstr(times)\n\ntibble [165 × 5] (S3: tbl_df/tbl/data.frame)\n $ Time   : 'times' num [1:165] 0.0915 0.0915 0.0899 0.0901 0.0902 ...\n  ..- attr(*, \"format\")= chr \"h:m:s\"\n $ Hours  : num [1:165] 2 2 2 2 2 2 2 2 2 2 ...\n $ Minutes: num [1:165] 11 11 9 9 9 8 10 9 10 9 ...\n $ Seconds: num [1:165] 48 48 24 43 57 16 2 50 20 3 ...\n $ ID     : int [1:165] 1 NA 3 4 5 6 7 8 9 10 ...\n\n\nThe only column both data sets seem to have in commonn is the ID one. This means we have to merge our two data sets on that column, so rows which have the same value in that column will be merged together. However, we have a slight problem: the ID column contains missing values (called NA). We will not be able to match these rows over both data sets, so we have to remove them. But first, let’s take a look at how many those are:\n\nsum(is.na(times$ID))\n\n[1] 5\n\nsum(is.na(winners$ID))\n\n[1] 5\n\n\nDon’t worry to much about what that code is doing right now, we will take a closer look later on. We seem to have five NAs in both data sets. This isn’t a whole lot, so we will just remove them, but keep in mind dealing with NAs is a broad topic for itself with many different possible approaches.\n\ntimes &lt;- drop_na(data = times, ID)\nwinners &lt;- drop_na(data = winners, ID)\n\nHere, we use a function from the tidyr package (which we installed among others when we installed the tidyverse) that removes all rows from the data that contain a NA in the ID column.\n\n\n\nNow we can merge:\n\nwinners_merged &lt;- merge(x = winners, \n                        y = times,\n                        by = \"ID\")\n\nWhat happens here? We take our two data sets, called winers and times and combine them on the column ID. Let’s take a look at the finished product:\n\nstr(winners_merged)\n\n'data.frame':   160 obs. of  9 variables:\n $ ID         : int  1 3 4 5 6 7 8 9 10 11 ...\n $ Category   : chr  \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Year       : num  1981 1982 1983 1984 1985 ...\n $ Athlete    : chr  \"Dick Beardsley (Tie)\" \"Hugh Jones\" \"Mike Gratton\" \"Charlie Spedding\" ...\n $ Nationality: chr  \"United States\" \"United Kingdom\" \"United Kingdom\" \"United Kingdom\" ...\n $ Time       : num  0.0915 0.0899 0.0901 0.0902 0.0891 ...\n $ Hours      : num  2 2 2 2 2 2 2 2 2 2 ...\n $ Minutes    : num  11 9 9 9 8 10 9 10 9 10 ...\n $ Seconds    : num  48 24 43 57 16 2 50 20 3 10 ...\n\n\nWe have merged the columns of the times data set onto the right the winners data.\n\n\n\nOne very important part of working with data in R is the subsetting of data. This means we select specific values from a data set.\nDivide by Category (Wheelchar vs. no wheelchair)\n\n\n\n\nwomen &lt;- winners[winners$Category == \"Women\", ]\n\n\nlm_rs &lt;- lm(Minutes_total ~ Year, women)\nsummary(lm_rs)\n\n# 614 min bei Year = 0, für jedes Jahr -0.23 Min weniger:\n# 614 + 2020 * -0.236\n\n\nplot(lm_rs)\n\n\nwinners$Minutes_total &lt;- winners$Hours * 60 + winners$Minutes\n\n\n\n\n\n\nlibrary(ggplot2)\nwinners %&gt;%\n  filter(Category %in% c(\"Men\", \"Women\")) %&gt;%\nggplot(data = ., aes(x = Year,\n                            y = Minutes_total,\n                     colour = Nationality,\n                     shape = Category)) +\n  geom_point()\n\n\nwinners %&gt;%\n  filter(Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\")) %&gt;%\nggplot(data = ., aes(x = Year,\n                            y = Minutes_total,\n                     colour = Nationality,\n                     shape = Category)) +\n  geom_point()\n\n\n# Für die Übung. \n#install.packages(\"tidytuesdayR\")\nlibrary(tidytuesdayR)\ntuesdata &lt;- tidytuesdayR::tt_load('2022-08-16')\n\n\n\n\nIn this tutorial we learned, that R is a flexible tool for editing and plotting data. Of course, we barely scratched the surface. Therefore, we want to dive a bit deeper into each step. Either follow the course, or navigate to the chapters you are most interested in."
  },
  {
    "objectID": "the_big_picture.html#packages",
    "href": "the_big_picture.html#packages",
    "title": "The big picture",
    "section": "",
    "text": "Packages are extensions to the base R you get by default. We already installed our first packages in About this workshop. Let’s keep doing that and install the following package as well:\n\ninstall.packages(\"tidyverse\")\n\nThe tidyverse is a collection of packages following a common philosophy, and facilitate many aspects of coding in R, for example data wrangling and plotting. We will use both functions from base R and from the tidyverse.\nJust by installing the packages, we can’t use them. We also have to load them into our R session:\n\nlibrary(tutoR)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThe top of your R Script should look something like this:\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"nickhaf/tutoR\")\ninstall.packages(\"tidyverse\")\n\nlibrary(tutoR)\nlibrary(tidyverse)"
  },
  {
    "objectID": "the_big_picture.html#load-data",
    "href": "the_big_picture.html#load-data",
    "title": "The big picture",
    "section": "",
    "text": "Data is loaded into R so you can work with it. Let’s do just that. First, you need to download the file “winners.rds” from this link and save it in your project folder (Tip: Save it in a new subfolder named “raw_data” or somewhat similar.). The data comes from the LondonMarathon package. Next, take a look at the ending. Different data formats need different functions for loading them into R. The winners.rds file has the ending .rds. So we use readRDS to load it into R. Here you can find a more thourough discussion about loading different data formats.\n\nwinners &lt;- readRDS(file = \"./raw_data/winners.rds\")\n\nThis will load the data into R and assigning it the name winners by using the &lt;-. You can see the data popping up in your Environment pane on the upper right. It is important you use the correct path, because otherwise R will not find your data file. Here the RStudio project we have created earlier comes in handy. It automatically knows our file lies within our project folder, which is why we can use a relative path, that starts at the project path and looks into the folder raw_data to open the file. Otherwise, we would have to use an absolute path (like “C:/Users/hafiznij/Documents/GitHub/r_tutorial/raw_data/london_marathon.rda” which will only work on my notebook, and only if my project stays in on this path."
  },
  {
    "objectID": "the_big_picture.html#take-a-look",
    "href": "the_big_picture.html#take-a-look",
    "title": "The big picture",
    "section": "",
    "text": "Now that we have our data loaded safely into R, we can get an overview with a multitude of commands. One of the most important ones might be View(), which will open the data set excel-style in a new window:\n\nView(winners)\n\nEspecially for bigger data sets, it might be more feasible to only look at the structure and not the whole data set:\n\nstr(winners)\n\ntibble [165 × 5] (S3: tbl_df/tbl/data.frame)\n $ Category   : chr [1:165] \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Year       : num [1:165] 1981 1981 1982 1983 1984 ...\n $ Athlete    : chr [1:165] \"Dick Beardsley (Tie)\" \"Inge Simonsen (Tie)\" \"Hugh Jones\" \"Mike Gratton\" ...\n $ Nationality: chr [1:165] \"United States\" \"Norway\" \"United Kingdom\" \"United Kingdom\" ...\n $ ID         : int [1:165] 1 NA 3 4 5 6 7 8 9 10 ...\n\n\nOn the left we can see the columns of this data.frame, named Category, Year, Athlete, Nationality and ID. On the right we see the first values in each column, for example 1981, 1981, 1982 etc … in the Year-column."
  },
  {
    "objectID": "the_big_picture.html#data-wrangling",
    "href": "the_big_picture.html#data-wrangling",
    "title": "The big picture",
    "section": "",
    "text": "Now, lets do something with this data. We want to answer the question if people have gotten faster at running marathons over that last 40 years. Sadly, the finishing times are not saved in this data set, but in another one named times.rda. So we need a way to combine them both, so we can run our analysis on the data.\nExercise: Download the second data set called “times.rda” and load it into R on your own.\n\n\nLet’s take a quick look at that one as well:\n\nstr(times)\n\ntibble [165 × 5] (S3: tbl_df/tbl/data.frame)\n $ Time   : 'times' num [1:165] 0.0915 0.0915 0.0899 0.0901 0.0902 ...\n  ..- attr(*, \"format\")= chr \"h:m:s\"\n $ Hours  : num [1:165] 2 2 2 2 2 2 2 2 2 2 ...\n $ Minutes: num [1:165] 11 11 9 9 9 8 10 9 10 9 ...\n $ Seconds: num [1:165] 48 48 24 43 57 16 2 50 20 3 ...\n $ ID     : int [1:165] 1 NA 3 4 5 6 7 8 9 10 ...\n\n\nThe only column both data sets seem to have in commonn is the ID one. This means we have to merge our two data sets on that column, so rows which have the same value in that column will be merged together. However, we have a slight problem: the ID column contains missing values (called NA). We will not be able to match these rows over both data sets, so we have to remove them. But first, let’s take a look at how many those are:\n\nsum(is.na(times$ID))\n\n[1] 5\n\nsum(is.na(winners$ID))\n\n[1] 5\n\n\nDon’t worry to much about what that code is doing right now, we will take a closer look later on. We seem to have five NAs in both data sets. This isn’t a whole lot, so we will just remove them, but keep in mind dealing with NAs is a broad topic for itself with many different possible approaches.\n\ntimes &lt;- drop_na(data = times, ID)\nwinners &lt;- drop_na(data = winners, ID)\n\nHere, we use a function from the tidyr package (which we installed among others when we installed the tidyverse) that removes all rows from the data that contain a NA in the ID column.\n\n\n\nNow we can merge:\n\nwinners_merged &lt;- merge(x = winners, \n                        y = times,\n                        by = \"ID\")\n\nWhat happens here? We take our two data sets, called winers and times and combine them on the column ID. Let’s take a look at the finished product:\n\nstr(winners_merged)\n\n'data.frame':   160 obs. of  9 variables:\n $ ID         : int  1 3 4 5 6 7 8 9 10 11 ...\n $ Category   : chr  \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Year       : num  1981 1982 1983 1984 1985 ...\n $ Athlete    : chr  \"Dick Beardsley (Tie)\" \"Hugh Jones\" \"Mike Gratton\" \"Charlie Spedding\" ...\n $ Nationality: chr  \"United States\" \"United Kingdom\" \"United Kingdom\" \"United Kingdom\" ...\n $ Time       : num  0.0915 0.0899 0.0901 0.0902 0.0891 ...\n $ Hours      : num  2 2 2 2 2 2 2 2 2 2 ...\n $ Minutes    : num  11 9 9 9 8 10 9 10 9 10 ...\n $ Seconds    : num  48 24 43 57 16 2 50 20 3 10 ...\n\n\nWe have merged the columns of the times data set onto the right the winners data.\n\n\n\nOne very important part of working with data in R is the subsetting of data. This means we select specific values from a data set.\nDivide by Category (Wheelchar vs. no wheelchair)\n\n\n\n\nwomen &lt;- winners[winners$Category == \"Women\", ]\n\n\nlm_rs &lt;- lm(Minutes_total ~ Year, women)\nsummary(lm_rs)\n\n# 614 min bei Year = 0, für jedes Jahr -0.23 Min weniger:\n# 614 + 2020 * -0.236\n\n\nplot(lm_rs)\n\n\nwinners$Minutes_total &lt;- winners$Hours * 60 + winners$Minutes"
  },
  {
    "objectID": "the_big_picture.html#plot-the-data",
    "href": "the_big_picture.html#plot-the-data",
    "title": "The big picture",
    "section": "",
    "text": "library(ggplot2)\nwinners %&gt;%\n  filter(Category %in% c(\"Men\", \"Women\")) %&gt;%\nggplot(data = ., aes(x = Year,\n                            y = Minutes_total,\n                     colour = Nationality,\n                     shape = Category)) +\n  geom_point()\n\n\nwinners %&gt;%\n  filter(Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\")) %&gt;%\nggplot(data = ., aes(x = Year,\n                            y = Minutes_total,\n                     colour = Nationality,\n                     shape = Category)) +\n  geom_point()\n\n\n# Für die Übung. \n#install.packages(\"tidytuesdayR\")\nlibrary(tidytuesdayR)\ntuesdata &lt;- tidytuesdayR::tt_load('2022-08-16')"
  },
  {
    "objectID": "the_big_picture.html#conclusion",
    "href": "the_big_picture.html#conclusion",
    "title": "The big picture",
    "section": "",
    "text": "In this tutorial we learned, that R is a flexible tool for editing and plotting data. Of course, we barely scratched the surface. Therefore, we want to dive a bit deeper into each step. Either follow the course, or navigate to the chapters you are most interested in."
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "In case you don’t use a notebook where you can install R and RStudio, or you don’t want to, you can use the posit Cloud service. It can be run in you browser, and provides the same functions and interface as if you were working with your own RStudio installation. And it’s free as well (at least 25 hours per month, but that should be more than enough for this workshop and probably for the following week).\n\nGo to posit Cloud.\nClick on GET STARTED.\nCreate an account (it’s free) and login.\nOn the upper right, click on New Project. This will create a new RStudio project, which you can use the same way as described in this tutorial.\n\n\n\n\n\n\n\n\n\n\n\"Hello World!\"\n\n[1] \"Hello World!\"\n\n\nTadaa, we just wrote our first line of code."
  },
  {
    "objectID": "setup.html#rstudio",
    "href": "setup.html#rstudio",
    "title": "Setup",
    "section": "",
    "text": "In case you don’t use a notebook where you can install R and RStudio, or you don’t want to, you can use the posit Cloud service. It can be run in you browser, and provides the same functions and interface as if you were working with your own RStudio installation. And it’s free as well (at least 25 hours per month, but that should be more than enough for this workshop and probably for the following week).\n\nGo to posit Cloud.\nClick on GET STARTED.\nCreate an account (it’s free) and login.\nOn the upper right, click on New Project. This will create a new RStudio project, which you can use the same way as described in this tutorial.\n\n\n\n\n\n\n\n\n\n\n\"Hello World!\"\n\n[1] \"Hello World!\"\n\n\nTadaa, we just wrote our first line of code."
  },
  {
    "objectID": "setup.html#workflow",
    "href": "setup.html#workflow",
    "title": "Setup",
    "section": "Workflow",
    "text": "Workflow\n\nScripts\nWhen only coding in our console we quickly run into the question where to save our code for further evaluation. Therefore, we want to write all our code that is worth saving into a script.\n\n\nRStudio Projects\nOver time, it will become increasingly hard to organize all your files, working directories and workspaces in a reasonable manner. For this, RStudio Projects can be used (highly recommended).\n\n\nExercises\n\nCreate a new folder for this tutorial, where all your files will go.\nCreate a new RStudio project and open it. Got to File - New Project - Existing Directory and select the path of the folder you created in step 1.\nCreate a new R Script by clicking on File - New File - R Script. Save it in you folder.\nTipp: Within your project folder create a folder named R, where all your R Scripts will go. You can do the same for data, plots etc. later on. This will help you to structure your working directory."
  },
  {
    "objectID": "setup.html#about-this-workshop",
    "href": "setup.html#about-this-workshop",
    "title": "Setup",
    "section": "About this workshop",
    "text": "About this workshop\nThis workshop will use a tutorial package (you will learn more about packages later) that can be run from within R and will provide interactive exercises. For now, please install that tutorial package by typing (and evaluating) the following code into your newly created R Script:\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"nickhaf/tutoR\")\n\nFor each chapter, there will be a short theory part. Most of the exercises can be run interactively with the tutoR package, but some will encourage you to use the RStudio environment, to get more familiar with it.\nFeel free to use any resources at you disposal to solve the exercises. That’s how you would also do it in real live. Just make sure you understand why your solution works (or why it doesn’t)."
  },
  {
    "objectID": "subsetting.html",
    "href": "subsetting.html",
    "title": "Subsetting data",
    "section": "",
    "text": "Please take a look at the different data structures in R if you are not familiar with them, before you start with this chapter.\nNow that we know how to store data in different formats, we also need to talk about how we can extract data from our data structures, so we can work with it.\n\n\nExtracting elements from vectors is pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets:\n\nvec_char &lt;- c(\"Jess\", \"Jane\", \"Joe\", \"Alex\")\nvec_char[2]\n\n[1] \"Jane\"\n\n\nOf course we can also do that for multiple elements:\n\nvec_char[c(2,3,4)]\n\n[1] \"Jane\" \"Joe\"  \"Alex\"\n\n## Or, less to write:\nvec_char[2:4]\n\n[1] \"Jane\" \"Joe\"  \"Alex\"\n\n\nAnother way would be to provide a logical vector, which defines for each position, if we want to extract the element or not:\n\nvec_char[c(TRUE, FALSE, TRUE, FALSE)]\n\n[1] \"Jess\" \"Joe\" \n\n\nThis will come in handy later on, when we want to extract rows from data frames by different conditions. If you feel like you need to, you can refresh on logical operators before continuing.\n\n\n\nWe will look at two ways to extract rows by conditions from data frames.\n\n\n\n# Define an example data frame\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n\nIn Base R, extracting rows or columns from a data frame is very similar to extracting values from a vector. We use square brackets [,], but this time with a , in the middle. In front of the , we write the rows we want to extract:\n\n# Extract the first and the fourth row\npersons[c(1, 4), ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n\n\nBehind it the columns:\n\n# Extract the second and the fourth column:\npersons[, c(2, 4)]\n\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n\n# Extract the columns by name:\npersons[, c(\"age\", \"big5_extro\")]\n\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n\n# Or only the column age (and turn it intow a vector right away):\npersons$age\n\n[1] 19 17 18 18\n\n\nAnd of course we can combine both calls:\n\npersons[c(1, 4), c(2, 4)]\n\n  age big5_extro\n1  19        3.5\n4  18        4.2\n\npersons[c(1, 4), c(\"age\", \"big5_extro\")]\n\n  age big5_extro\n1  19        3.5\n4  18        4.2\n\n\nWe can also use boolean values:\n\npersons[c(TRUE, FALSE, FALSE, TRUE), c(TRUE, FALSE, FALSE, TRUE)]\n\n   name big5_extro\n1  Anna        3.5\n4 Jessi        4.2\n\n\nNow the stuff we looked at in logical operators comes in handy! We can now filter rows which match some condition. For example, we might want to look at all persons which are 18 years old:\n\npersons[persons$age == 18, ]\n\n   name age birth_month big5_extro\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n\n\nTake a close look at the comparison before the ,:\n\npersons$age == 18\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\npersons$age is a vector, so comparing its values to a specified value yields a logical vector with the respective TRUE and FALSE values. We can insert this logical vector in front of the , to extract all rows corresponding to that condition.\nWe can also combine multiple logical vectors using & (“and”) and | (“or”). For example, we might want to look at all persons older than 17 which have an extroversion rating below 4.5:\n\npersons[persons$age &gt; 17 & persons$big5_extro &lt; 4.5, ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n\n\nOr at all persons, that are either 18 years old, or have an extroversion rating above 3:\n\npersons[persons$age == 18 | persons$big5_extro &gt; 3, ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n\n\nIn the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Enter, the filter() function:\n\n\n\nThe dplyr package is part of the tidyverse and provides a grammar of data manipulation. We can use filter() to subset rows from a data frame:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nfilter(persons, age == 18, big5_extro &lt; 4.5)\n\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n\n\nNote how we can just write our conditions without connecting them with & (filter() does that automatically for us). Also, we don’t have to put the column names into \"\", because filter() knows that this are column names of the persons data frame, which makes coding a bit more pleasant.\n\n\nHold on! Normally, we wouldn’t write tidyverse code like that. Instead, we would use the pipe operator %&gt;% (than do), which makes it easy to connect multiple function calls:\n\npersons %&gt;%\n  filter(age == 18, big5_extro &lt; 4.5)\n\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n\n\nHere, we first input the data frame we want to manipulate. Than we filter, as specified by the pipe operator. Like this, we can easily connect multiple function calls instead of nesting them within multiple brackets, which increases the readability massively:\n\nstart_value &lt;- -8\nsqrt(mean(abs((rep(seq(from = start_value, to = 20, by = 0.5), 4)))))\n\n[1] 2.895853\n\n\nbecomes:\n\nstart_value &lt;- -8\nstart_value %&gt;%\n  seq(from = ., to = 20, by = 0.5) %&gt;%\n  rep(times = 4) %&gt;%\n  abs %&gt;%\n  mean %&gt;%\n  sqrt\n\n[1] 2.895853\n\n\nMuch nicer to read, right? Some notes on this syntax: If we don’t have any additonal arguments we want to put into the function, we can just write the function name without any brackets. The pipe operator will give the result of the last function as input into the next function. If we want to clearly state which of the function arguments should receive the input, we can write a ., which can be read as output of the previous function call."
  },
  {
    "objectID": "subsetting.html#vectors",
    "href": "subsetting.html#vectors",
    "title": "Subsetting data",
    "section": "",
    "text": "Extracting elements from vectors is pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets:\n\nvec_char &lt;- c(\"Jess\", \"Jane\", \"Joe\", \"Alex\")\nvec_char[2]\n\n[1] \"Jane\"\n\n\nOf course we can also do that for multiple elements:\n\nvec_char[c(2,3,4)]\n\n[1] \"Jane\" \"Joe\"  \"Alex\"\n\n## Or, less to write:\nvec_char[2:4]\n\n[1] \"Jane\" \"Joe\"  \"Alex\"\n\n\nAnother way would be to provide a logical vector, which defines for each position, if we want to extract the element or not:\n\nvec_char[c(TRUE, FALSE, TRUE, FALSE)]\n\n[1] \"Jess\" \"Joe\" \n\n\nThis will come in handy later on, when we want to extract rows from data frames by different conditions. If you feel like you need to, you can refresh on logical operators before continuing."
  },
  {
    "objectID": "subsetting.html#data-frames",
    "href": "subsetting.html#data-frames",
    "title": "Subsetting data",
    "section": "",
    "text": "We will look at two ways to extract rows by conditions from data frames.\n\n\n\n# Define an example data frame\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n\nIn Base R, extracting rows or columns from a data frame is very similar to extracting values from a vector. We use square brackets [,], but this time with a , in the middle. In front of the , we write the rows we want to extract:\n\n# Extract the first and the fourth row\npersons[c(1, 4), ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n\n\nBehind it the columns:\n\n# Extract the second and the fourth column:\npersons[, c(2, 4)]\n\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n\n# Extract the columns by name:\npersons[, c(\"age\", \"big5_extro\")]\n\n  age big5_extro\n1  19        3.5\n2  17        2.0\n3  18        4.5\n4  18        4.2\n\n# Or only the column age (and turn it intow a vector right away):\npersons$age\n\n[1] 19 17 18 18\n\n\nAnd of course we can combine both calls:\n\npersons[c(1, 4), c(2, 4)]\n\n  age big5_extro\n1  19        3.5\n4  18        4.2\n\npersons[c(1, 4), c(\"age\", \"big5_extro\")]\n\n  age big5_extro\n1  19        3.5\n4  18        4.2\n\n\nWe can also use boolean values:\n\npersons[c(TRUE, FALSE, FALSE, TRUE), c(TRUE, FALSE, FALSE, TRUE)]\n\n   name big5_extro\n1  Anna        3.5\n4 Jessi        4.2\n\n\nNow the stuff we looked at in logical operators comes in handy! We can now filter rows which match some condition. For example, we might want to look at all persons which are 18 years old:\n\npersons[persons$age == 18, ]\n\n   name age birth_month big5_extro\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n\n\nTake a close look at the comparison before the ,:\n\npersons$age == 18\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\npersons$age is a vector, so comparing its values to a specified value yields a logical vector with the respective TRUE and FALSE values. We can insert this logical vector in front of the , to extract all rows corresponding to that condition.\nWe can also combine multiple logical vectors using & (“and”) and | (“or”). For example, we might want to look at all persons older than 17 which have an extroversion rating below 4.5:\n\npersons[persons$age &gt; 17 & persons$big5_extro &lt; 4.5, ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n4 Jessi  18         Mar        4.2\n\n\nOr at all persons, that are either 18 years old, or have an extroversion rating above 3:\n\npersons[persons$age == 18 | persons$big5_extro &gt; 3, ]\n\n   name age birth_month big5_extro\n1  Anna  19         Jan        3.5\n3  John  18         Oct        4.5\n4 Jessi  18         Mar        4.2\n\n\nIn the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Enter, the filter() function:\n\n\n\nThe dplyr package is part of the tidyverse and provides a grammar of data manipulation. We can use filter() to subset rows from a data frame:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nfilter(persons, age == 18, big5_extro &lt; 4.5)\n\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n\n\nNote how we can just write our conditions without connecting them with & (filter() does that automatically for us). Also, we don’t have to put the column names into \"\", because filter() knows that this are column names of the persons data frame, which makes coding a bit more pleasant.\n\n\nHold on! Normally, we wouldn’t write tidyverse code like that. Instead, we would use the pipe operator %&gt;% (than do), which makes it easy to connect multiple function calls:\n\npersons %&gt;%\n  filter(age == 18, big5_extro &lt; 4.5)\n\n   name age birth_month big5_extro\n1 Jessi  18         Mar        4.2\n\n\nHere, we first input the data frame we want to manipulate. Than we filter, as specified by the pipe operator. Like this, we can easily connect multiple function calls instead of nesting them within multiple brackets, which increases the readability massively:\n\nstart_value &lt;- -8\nsqrt(mean(abs((rep(seq(from = start_value, to = 20, by = 0.5), 4)))))\n\n[1] 2.895853\n\n\nbecomes:\n\nstart_value &lt;- -8\nstart_value %&gt;%\n  seq(from = ., to = 20, by = 0.5) %&gt;%\n  rep(times = 4) %&gt;%\n  abs %&gt;%\n  mean %&gt;%\n  sqrt\n\n[1] 2.895853\n\n\nMuch nicer to read, right? Some notes on this syntax: If we don’t have any additonal arguments we want to put into the function, we can just write the function name without any brackets. The pipe operator will give the result of the last function as input into the next function. If we want to clearly state which of the function arguments should receive the input, we can write a ., which can be read as output of the previous function call."
  },
  {
    "objectID": "data_structures.html",
    "href": "data_structures.html",
    "title": "Data structures",
    "section": "",
    "text": "There are five main data structures in R which differ on their dimensions (one dimension, two dimensions, n dimensions) and the type of the elements they are containing (same type, different types):1\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\natomic vector\nlist\n\n\n2d\nmatrix\ndata.frame\n\n\nnd\narray\n\n\n\n\n\nLet’s take a closer look at the two we will use mostly throughout this workshop:\n\n\nAtomic vectors (from hereon only called vectors) contain elements of only the same type:\n\nnum_vec &lt;- c(2023, 8, 8)\nnum_vec\n\n[1] 2023    8    8\n\nchar_vec &lt;- c(\"This\", \"is\", \"a\", \"vec\", \".\")\nchar_vec\n\n[1] \"This\" \"is\"   \"a\"    \"vec\"  \".\"   \n\nlog_vec &lt;- c(TRUE, FALSE)\nlog_vec\n\n[1]  TRUE FALSE\n\n\nThe c() stands for combine, or concatenate, and is the basic function for building a vector out of single elements.\n\n\nIf we take a look at the structure of the vectors we have just created, we see se a short description of the data type we are dealing with in front of the vector:\n\nstr(num_vec)\n\n num [1:3] 2023 8 8\n\nstr(char_vec)\n\n chr [1:5] \"This\" \"is\" \"a\" \"vec\" \".\"\n\nstr(log_vec)\n\n logi [1:2] TRUE FALSE\n\n\nThe first one is num (numeric) so it only stores numeric values. The second one is char (character), so it only can contain strings. And last but not least we have logi (logical) for boolean values. Why is that important? Well, some functions only make sense for specific data types. For example:\n\nmean(char_vec)\n\nWarning in mean.default(char_vec): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\ngives us a warning, because the input has the wrong format.\n\n\n\n\nA data frame is two dimensional and can store elements of different types. It is the closest to data tables we are probably most used to working with.\n\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extra = c(3.5, 2, 4.5, 4.2)\n                      )\n\nNote that we do nothing else here than combining vectors to a data frame. Each vector will be one column.\n\n\nA special type of data frames are the so called tibbles. Tibbles are a modern version of data frames and the standard data frame type of the tidyverse, as they have some advantageous characteristics (e.g., note the prettier printing of the data frame). So don’t be confused if you run into them, in general they behave like data frames.\n\npersons_tibble &lt;- tibble::tibble(\n  name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n  age = c(19, 17, 18, 18),\n  birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n  big5_extra = c(3.5, 2, 4.5, 4.2)\n)\npersons_tibble\n\n# A tibble: 4 × 4\n  name    age birth_month big5_extra\n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1 Anna     19 Jan                3.5\n2 Alex     17 Sep                2  \n3 John     18 Oct                4.5\n4 Jessi    18 Mar                4.2\n\n\n\n\n\n\nA list is a one dimensional object, which can, unlike like a vector, contain elements of different types, but also of different lengths. For example, we can store a vectors of different lengths and data frames in a list, which makes it the most versatile data structure:\n\npersonality_rating &lt;- list(\n     big5 = data.frame(name = c(\"Jessi\", \"John\"),\n                       extraversion = c(4.3, 2), \n                       openness = c(3.8, 4)),\n     rating_type = \"self_rating\"\n     )\npersonality_rating\n\n$big5\n   name extraversion openness\n1 Jessi          4.3      3.8\n2  John          2.0      4.0\n\n$rating_type\n[1] \"self_rating\"\n\n\nHere, we define the list personality_rating, which includes a data frame with the personality rating, and some meta information in the form of a character vector, describing the rating type. We won’t use it any more in this workshop, but keep in mind it exists, as it quickly becomes necessary for managing more complex tasks.\nInstead, we are now well equipped to get started with some data manipulation and transformation."
  },
  {
    "objectID": "data_structures.html#vector",
    "href": "data_structures.html#vector",
    "title": "Data structures",
    "section": "",
    "text": "Atomic vectors (from hereon only called vectors) contain elements of only the same type:\n\nnum_vec &lt;- c(2023, 8, 8)\nnum_vec\n\n[1] 2023    8    8\n\nchar_vec &lt;- c(\"This\", \"is\", \"a\", \"vec\", \".\")\nchar_vec\n\n[1] \"This\" \"is\"   \"a\"    \"vec\"  \".\"   \n\nlog_vec &lt;- c(TRUE, FALSE)\nlog_vec\n\n[1]  TRUE FALSE\n\n\nThe c() stands for combine, or concatenate, and is the basic function for building a vector out of single elements.\n\n\nIf we take a look at the structure of the vectors we have just created, we see se a short description of the data type we are dealing with in front of the vector:\n\nstr(num_vec)\n\n num [1:3] 2023 8 8\n\nstr(char_vec)\n\n chr [1:5] \"This\" \"is\" \"a\" \"vec\" \".\"\n\nstr(log_vec)\n\n logi [1:2] TRUE FALSE\n\n\nThe first one is num (numeric) so it only stores numeric values. The second one is char (character), so it only can contain strings. And last but not least we have logi (logical) for boolean values. Why is that important? Well, some functions only make sense for specific data types. For example:\n\nmean(char_vec)\n\nWarning in mean.default(char_vec): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\ngives us a warning, because the input has the wrong format."
  },
  {
    "objectID": "data_structures.html#data-frame",
    "href": "data_structures.html#data-frame",
    "title": "Data structures",
    "section": "",
    "text": "A data frame is two dimensional and can store elements of different types. It is the closest to data tables we are probably most used to working with.\n\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extra = c(3.5, 2, 4.5, 4.2)\n                      )\n\nNote that we do nothing else here than combining vectors to a data frame. Each vector will be one column.\n\n\nA special type of data frames are the so called tibbles. Tibbles are a modern version of data frames and the standard data frame type of the tidyverse, as they have some advantageous characteristics (e.g., note the prettier printing of the data frame). So don’t be confused if you run into them, in general they behave like data frames.\n\npersons_tibble &lt;- tibble::tibble(\n  name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n  age = c(19, 17, 18, 18),\n  birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n  big5_extra = c(3.5, 2, 4.5, 4.2)\n)\npersons_tibble\n\n# A tibble: 4 × 4\n  name    age birth_month big5_extra\n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1 Anna     19 Jan                3.5\n2 Alex     17 Sep                2  \n3 John     18 Oct                4.5\n4 Jessi    18 Mar                4.2"
  },
  {
    "objectID": "data_structures.html#honorable-mention-list",
    "href": "data_structures.html#honorable-mention-list",
    "title": "Data structures",
    "section": "",
    "text": "A list is a one dimensional object, which can, unlike like a vector, contain elements of different types, but also of different lengths. For example, we can store a vectors of different lengths and data frames in a list, which makes it the most versatile data structure:\n\npersonality_rating &lt;- list(\n     big5 = data.frame(name = c(\"Jessi\", \"John\"),\n                       extraversion = c(4.3, 2), \n                       openness = c(3.8, 4)),\n     rating_type = \"self_rating\"\n     )\npersonality_rating\n\n$big5\n   name extraversion openness\n1 Jessi          4.3      3.8\n2  John          2.0      4.0\n\n$rating_type\n[1] \"self_rating\"\n\n\nHere, we define the list personality_rating, which includes a data frame with the personality rating, and some meta information in the form of a character vector, describing the rating type. We won’t use it any more in this workshop, but keep in mind it exists, as it quickly becomes necessary for managing more complex tasks.\nInstead, we are now well equipped to get started with some data manipulation and transformation."
  },
  {
    "objectID": "data_structures.html#footnotes",
    "href": "data_structures.html#footnotes",
    "title": "Data structures",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTable from Advanced R.↩︎"
  }
]