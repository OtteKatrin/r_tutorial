[
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "In case you don’t use a notebook where you can install R and RStudio, or you don’t want to, you can use the posit Cloud service. It can be run in you browser, and provides the same functions and interface as if you were working with your own RStudio installation. And it’s free as well (at least 25 hours per month, but that should be more than enough for this workshop and probably for the following week).\n\nGo to posit Cloud.\nClick on GET STARTED.\nCreate an account (it’s free) and login.\nOn the upper right, click on New Project. This will create a new RStudio project, which you can use the same way as described in this tutorial.\n\n\n\n\n\n\n\nprint(\"Hello World!\")\n\n[1] \"Hello World!\"\n\n\nTadaa, we just wrote our first line of code.\n\n\n\nYou can also work directly in the console, for example to try out things. Type, into your console:\n\n# Sum two values\n10 + 5\n\n[1] 15\n\n\nBy the way: Code lines, that are preceded by a # are commented out, and will not be evaluated.\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen only coding in our console we quickly run into the question where to save our code for further evaluation. Therefore, we want to write all our important code into a script.\n\n\n\n\n\nOver time, it will become increasingly hard to organize all your files, working directories and workspaces in a reasonable manner. For this, RStudio Projects can be used (highly recommended).\n\n\n\n\nCreate a new folder for this tutorial, where all your files will go.\nCreate a new RStudio project and open it. Go to File - New Project - Existing Directory and select the path of the folder you created in step 1.\nCreate a new R Script by clicking on File - New File - R Script. Save it in you folder.\n\n\n\n\n\n\n\nTip\n\n\n\nWithin your project folder create a folder named R, where all your R Scripts will go. You can do the same for data, plots etc. later on. This will help you to structure your working directory.\n\n\n\n\n\n\nThis workshop will use a tutorial package (you will learn more about packages later) that can be run from within R and will provide interactive exercises. For now, please install that tutorial package by typing (and evaluating) the following code into your newly created R Script:\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"nickhaf/tutoR\")\n\nFor each chapter, there will be a short theory part. Most of the exercises can be run interactively with the tutoR package, but some will encourage you to use the RStudio environment, to get more familiar with it.\nFeel free to use any resources at you disposal to solve the exercises. That’s how you would also do it in real live. Just make sure you understand why your solution works (or why it doesn’t)."
  },
  {
    "objectID": "setup.html#rstudio",
    "href": "setup.html#rstudio",
    "title": "Setup",
    "section": "",
    "text": "In case you don’t use a notebook where you can install R and RStudio, or you don’t want to, you can use the posit Cloud service. It can be run in you browser, and provides the same functions and interface as if you were working with your own RStudio installation. And it’s free as well (at least 25 hours per month, but that should be more than enough for this workshop and probably for the following week).\n\nGo to posit Cloud.\nClick on GET STARTED.\nCreate an account (it’s free) and login.\nOn the upper right, click on New Project. This will create a new RStudio project, which you can use the same way as described in this tutorial.\n\n\n\n\n\n\n\nprint(\"Hello World!\")\n\n[1] \"Hello World!\"\n\n\nTadaa, we just wrote our first line of code.\n\n\n\nYou can also work directly in the console, for example to try out things. Type, into your console:\n\n# Sum two values\n10 + 5\n\n[1] 15\n\n\nBy the way: Code lines, that are preceded by a # are commented out, and will not be evaluated."
  },
  {
    "objectID": "setup.html#workflow",
    "href": "setup.html#workflow",
    "title": "Setup",
    "section": "",
    "text": "Warning\n\n\n\nWhen only coding in our console we quickly run into the question where to save our code for further evaluation. Therefore, we want to write all our important code into a script.\n\n\n\n\n\nOver time, it will become increasingly hard to organize all your files, working directories and workspaces in a reasonable manner. For this, RStudio Projects can be used (highly recommended).\n\n\n\n\nCreate a new folder for this tutorial, where all your files will go.\nCreate a new RStudio project and open it. Go to File - New Project - Existing Directory and select the path of the folder you created in step 1.\nCreate a new R Script by clicking on File - New File - R Script. Save it in you folder.\n\n\n\n\n\n\n\nTip\n\n\n\nWithin your project folder create a folder named R, where all your R Scripts will go. You can do the same for data, plots etc. later on. This will help you to structure your working directory."
  },
  {
    "objectID": "setup.html#about-this-workshop",
    "href": "setup.html#about-this-workshop",
    "title": "Setup",
    "section": "",
    "text": "This workshop will use a tutorial package (you will learn more about packages later) that can be run from within R and will provide interactive exercises. For now, please install that tutorial package by typing (and evaluating) the following code into your newly created R Script:\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"nickhaf/tutoR\")\n\nFor each chapter, there will be a short theory part. Most of the exercises can be run interactively with the tutoR package, but some will encourage you to use the RStudio environment, to get more familiar with it.\nFeel free to use any resources at you disposal to solve the exercises. That’s how you would also do it in real live. Just make sure you understand why your solution works (or why it doesn’t)."
  },
  {
    "objectID": "exercise_overview.html",
    "href": "exercise_overview.html",
    "title": "Exercises",
    "section": "",
    "text": "1\nOver the course of this workshop, you can work on exercises to train the theoretical knowledge acquired in the chapters. Most of these exercises will use the characters data set, which provides psychometric ratings for many different TV characters. A large number of people rated different TV characters on a personality scale developed by the author of the questionnaire.\nYou will load the data, prepare it for analyses and plot it in the end, if you follow the whole workshop."
  },
  {
    "objectID": "exercise_overview.html#footnotes",
    "href": "exercise_overview.html#footnotes",
    "title": "Exercises",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nImage by Ilse Orsen on Unsplash.↩︎"
  },
  {
    "objectID": "qmd/manipulation/manipulation.html",
    "href": "qmd/manipulation/manipulation.html",
    "title": "Data wrangling",
    "section": "",
    "text": "## merge two data frames by different columns:\nmerge(\n  x = winners,\n  y = continents,\n  by.x = \"Nationality\",\n  by.y = \"Entity\"\n)\n\n## Add a new column:\nwinners_continents$Seconds_total &lt;- winners_continents$Hours * 60^2 +\n                                    winners_continents$Minutes * 60 +\n                                    winners_continents$Seconds\n\n## Show missing values:\nis.na(winners_continents$Hours)\n\n## Remove rows that have a missing in the specified column:\nwinners_continents_na &lt;- winners_continents[!is.na(winners_continents$Hours), ]\n\n## Add a new column conditionally to contents of other columns: \nwinners_continents$Wheelchair &lt;- ifelse(\n  winners_continents$Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\"),\n  yes = TRUE,\n  no = FALSE\n)\n\n\n\nlibrary(dplyr)\n\n## Add a new column using mutate():\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(Minutes_total = winners_continents$Hours * 60 +\n                         winners_continents$Minutes *\n                         winners_continents$Seconds / 60)\n\n\n\n\n\nSuppose we want to look at the winners by continent (see last chapter for the data set). In this case, we will have to add a list assigning each Nationality a continent. We can easily find such a list online, for example at ourworldindata.org. I have already downloaded the .csv, and we have already loaded it into R in the exercise 2 of load data:\n\nwinners &lt;- readRDS(file = \"./raw_data/winners.rds\")\ncontinents &lt;- read.csv(\n  file = \"./raw_data/continents.csv\",\n  sep = \";\"\n)\n\n\n\n\n\n\n\nTo merge two data frames that include information that belongs together, we need a common column, on which we can combine them. In our case, this is the column containing the country, but they are named differently. This doesn’t pose a problem, as we can define which columns should be taken from which data frame for merging:\n\nwinners_continents &lt;- merge(\n  x = winners,\n  y = continents,\n  by.x = \"Nationality\",\n  by.y = \"Entity\"\n)\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent\n1  AUS   2015       Oceania\n2  AUS   2015       Oceania\n3  AUS   2015       Oceania\n4  BEL   2015        Europe\n5  CAN   2015 North America\n6  CAN   2015 North America\n\n\nGreat! Now the information that belongs together is stored together.\n\n\n\nAdding new columns to a data frame is pretty straight forward. We just define the column name, and then assign it some input. For example, we could be interested in calculating the seconds each person needed to finish, and add that as a new column:\n\nwinners_continents$Seconds_total &lt;- winners_continents$Hours * 60^2 +\n                                    winners_continents$Minutes * 60 +\n                                    winners_continents$Seconds\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent Seconds_total\n1  AUS   2015       Oceania          5337\n2  AUS   2015       Oceania          5489\n3  AUS   2015       Oceania          6178\n4  BEL   2015        Europe          6250\n5  CAN   2015 North America          7297\n6  CAN   2015 North America          5721\n\n\nOr, using the tidyverse with the help of mutate():\n\n\nlibrary(dplyr)\n\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(Minutes_total = winners_continents$Hours * 60 + winners_continents$Minutes * winners_continents$Seconds / 60)\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent Seconds_total Minutes_total\n1  AUS   2015       Oceania          5337      86.60000\n2  AUS   2015       Oceania          5489      74.98333\n3  AUS   2015       Oceania          6178     100.60000\n4  BEL   2015        Europe          6250      67.33333\n5  CAN   2015 North America          7297     120.61667\n6  CAN   2015 North America          5721      72.25000\n\n\n\nHold on! Both new columns seem to have missing values, which is an important concept which we haven’t talked about yet. So let’s do that quickly, and then merge!\n\n\n\nMissing values are denoted in R by NA (or NaN in some cases). They pretty strongly nullify a calculation - if one missing value is found somewhere along the line, the result will also be NA (if not specified otherwise):\n\n4 + 5 + NA\n\n[1] NA\n\n\nThat’s why our newly build columns include NAs: The column Hours already had some, and by adding with NAs we just produced new ones.\nTo check if values are NA, we can use is.na():\n\nis.na(winners_continents$Hours)\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n...\n\n\nSome TRUEs, so there are missing values here. Let’s count them (Summing a logical vector counts the number of TRUE values.):\n\nsum(is.na(winners_continents$Hours))\n\n[1] 5\n\n\nWe seem to have 5 missings in this column. There are multiple different ways to deal with missings. For this tutorial, we just remove cases with missing values on the Hours variable:\n\nwinners_continents_na &lt;- winners_continents[!is.na(winners_continents$Hours), ]\n\nWhat happens here? Like always when filtering specific rows, we define a logical vector, which has a TRUE for all rows that have a missing on ID and a FALSE for all others (by using the ! operator, which inverts the boolean values - otherwise we would extract all rows with missing values in the Hours column):\n\n!is.na(winners_continents$Hours)\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n...\n\n\nWe also assign a new name to the resulting data frame.\n\n\n\nWe can also add new values conditionally, for example by using the ifelse() function. For example, let’s build a composite variable which summarizes whether the category was Whelchair or not:\n\nwinners_continents$Wheelchair &lt;- ifelse(\n  winners_continents$Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\"),\n  yes = TRUE,\n  no = FALSE\n)\nwinners_continents\n\n       Nationality         Category Year.x                    Athlete Hours\n1        Australia   Wheelchair Men   2009              Kurt Fearnley     1\n2        Australia   Wheelchair Men   2013              Kurt Fearnley     1\n3        Australia Wheelchair Women   2018         Madison de Rozario     1\n...\n\n\n\n\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(over_3_h = ifelse(\n    winners_continents$Hours &lt; 2,\n    yes = \"below\",\n    no  = \"over\"\n  ))\n\nwinners_continents\n\n       Nationality         Category Year.x                    Athlete Hours\n1        Australia   Wheelchair Men   2009              Kurt Fearnley     1\n2        Australia   Wheelchair Men   2013              Kurt Fearnley     1\n3        Australia Wheelchair Women   2018         Madison de Rozario     1\n..."
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#overview-of-the-main-commands-in-this-section",
    "href": "qmd/manipulation/manipulation.html#overview-of-the-main-commands-in-this-section",
    "title": "Data wrangling",
    "section": "",
    "text": "## merge two data frames by different columns:\nmerge(\n  x = winners,\n  y = continents,\n  by.x = \"Nationality\",\n  by.y = \"Entity\"\n)\n\n## Add a new column:\nwinners_continents$Seconds_total &lt;- winners_continents$Hours * 60^2 +\n                                    winners_continents$Minutes * 60 +\n                                    winners_continents$Seconds\n\n## Show missing values:\nis.na(winners_continents$Hours)\n\n## Remove rows that have a missing in the specified column:\nwinners_continents_na &lt;- winners_continents[!is.na(winners_continents$Hours), ]\n\n## Add a new column conditionally to contents of other columns: \nwinners_continents$Wheelchair &lt;- ifelse(\n  winners_continents$Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\"),\n  yes = TRUE,\n  no = FALSE\n)\n\n\n\nlibrary(dplyr)\n\n## Add a new column using mutate():\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(Minutes_total = winners_continents$Hours * 60 +\n                         winners_continents$Minutes *\n                         winners_continents$Seconds / 60)"
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#data-set",
    "href": "qmd/manipulation/manipulation.html#data-set",
    "title": "Data wrangling",
    "section": "",
    "text": "Suppose we want to look at the winners by continent (see last chapter for the data set). In this case, we will have to add a list assigning each Nationality a continent. We can easily find such a list online, for example at ourworldindata.org. I have already downloaded the .csv, and we have already loaded it into R in the exercise 2 of load data:\n\nwinners &lt;- readRDS(file = \"./raw_data/winners.rds\")\ncontinents &lt;- read.csv(\n  file = \"./raw_data/continents.csv\",\n  sep = \";\"\n)"
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#merging",
    "href": "qmd/manipulation/manipulation.html#merging",
    "title": "Data wrangling",
    "section": "",
    "text": "To merge two data frames that include information that belongs together, we need a common column, on which we can combine them. In our case, this is the column containing the country, but they are named differently. This doesn’t pose a problem, as we can define which columns should be taken from which data frame for merging:\n\nwinners_continents &lt;- merge(\n  x = winners,\n  y = continents,\n  by.x = \"Nationality\",\n  by.y = \"Entity\"\n)\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent\n1  AUS   2015       Oceania\n2  AUS   2015       Oceania\n3  AUS   2015       Oceania\n4  BEL   2015        Europe\n5  CAN   2015 North America\n6  CAN   2015 North America\n\n\nGreat! Now the information that belongs together is stored together."
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#new-columns",
    "href": "qmd/manipulation/manipulation.html#new-columns",
    "title": "Data wrangling",
    "section": "",
    "text": "Adding new columns to a data frame is pretty straight forward. We just define the column name, and then assign it some input. For example, we could be interested in calculating the seconds each person needed to finish, and add that as a new column:\n\nwinners_continents$Seconds_total &lt;- winners_continents$Hours * 60^2 +\n                                    winners_continents$Minutes * 60 +\n                                    winners_continents$Seconds\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent Seconds_total\n1  AUS   2015       Oceania          5337\n2  AUS   2015       Oceania          5489\n3  AUS   2015       Oceania          6178\n4  BEL   2015        Europe          6250\n5  CAN   2015 North America          7297\n6  CAN   2015 North America          5721\n\n\nOr, using the tidyverse with the help of mutate():\n\n\nlibrary(dplyr)\n\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(Minutes_total = winners_continents$Hours * 60 + winners_continents$Minutes * winners_continents$Seconds / 60)\nhead(winners_continents)\n\n  Nationality         Category Year.x            Athlete Hours Minutes Seconds\n1   Australia   Wheelchair Men   2009      Kurt Fearnley     1      28      57\n2   Australia   Wheelchair Men   2013      Kurt Fearnley     1      31      29\n3   Australia Wheelchair Women   2018 Madison de Rozario     1      42      58\n4     Belgium   Wheelchair Men   1993    George Vandamme     1      44      10\n5      Canada   Wheelchair Men   1988          Ted Vince     2       1      37\n6      Canada   Wheelchair Men   2010       Josh Cassidy     1      35      21\n  Code Year.y     Continent Seconds_total Minutes_total\n1  AUS   2015       Oceania          5337      86.60000\n2  AUS   2015       Oceania          5489      74.98333\n3  AUS   2015       Oceania          6178     100.60000\n4  BEL   2015        Europe          6250      67.33333\n5  CAN   2015 North America          7297     120.61667\n6  CAN   2015 North America          5721      72.25000\n\n\n\nHold on! Both new columns seem to have missing values, which is an important concept which we haven’t talked about yet. So let’s do that quickly, and then merge!"
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#missing-values",
    "href": "qmd/manipulation/manipulation.html#missing-values",
    "title": "Data wrangling",
    "section": "",
    "text": "Missing values are denoted in R by NA (or NaN in some cases). They pretty strongly nullify a calculation - if one missing value is found somewhere along the line, the result will also be NA (if not specified otherwise):\n\n4 + 5 + NA\n\n[1] NA\n\n\nThat’s why our newly build columns include NAs: The column Hours already had some, and by adding with NAs we just produced new ones.\nTo check if values are NA, we can use is.na():\n\nis.na(winners_continents$Hours)\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n...\n\n\nSome TRUEs, so there are missing values here. Let’s count them (Summing a logical vector counts the number of TRUE values.):\n\nsum(is.na(winners_continents$Hours))\n\n[1] 5\n\n\nWe seem to have 5 missings in this column. There are multiple different ways to deal with missings. For this tutorial, we just remove cases with missing values on the Hours variable:\n\nwinners_continents_na &lt;- winners_continents[!is.na(winners_continents$Hours), ]\n\nWhat happens here? Like always when filtering specific rows, we define a logical vector, which has a TRUE for all rows that have a missing on ID and a FALSE for all others (by using the ! operator, which inverts the boolean values - otherwise we would extract all rows with missing values in the Hours column):\n\n!is.na(winners_continents$Hours)\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n...\n\n\nWe also assign a new name to the resulting data frame."
  },
  {
    "objectID": "qmd/manipulation/manipulation.html#ifelse",
    "href": "qmd/manipulation/manipulation.html#ifelse",
    "title": "Data wrangling",
    "section": "",
    "text": "We can also add new values conditionally, for example by using the ifelse() function. For example, let’s build a composite variable which summarizes whether the category was Whelchair or not:\n\nwinners_continents$Wheelchair &lt;- ifelse(\n  winners_continents$Category %in% c(\"Wheelchair Men\", \"Wheelchair Women\"),\n  yes = TRUE,\n  no = FALSE\n)\nwinners_continents\n\n       Nationality         Category Year.x                    Athlete Hours\n1        Australia   Wheelchair Men   2009              Kurt Fearnley     1\n2        Australia   Wheelchair Men   2013              Kurt Fearnley     1\n3        Australia Wheelchair Women   2018         Madison de Rozario     1\n...\n\n\n\n\nwinners_continents &lt;- winners_continents %&gt;%\n  mutate(over_3_h = ifelse(\n    winners_continents$Hours &lt; 2,\n    yes = \"below\",\n    no  = \"over\"\n  ))\n\nwinners_continents\n\n       Nationality         Category Year.x                    Athlete Hours\n1        Australia   Wheelchair Men   2009              Kurt Fearnley     1\n2        Australia   Wheelchair Men   2013              Kurt Fearnley     1\n3        Australia Wheelchair Women   2018         Madison de Rozario     1\n..."
  },
  {
    "objectID": "qmd/data_structures/data_structures.html",
    "href": "qmd/data_structures/data_structures.html",
    "title": "Data structures",
    "section": "",
    "text": "There are five main data structures in R which differ on their dimensions (one dimension, two dimensions, n dimensions) and the type of the elements they are containing (same type, different types):1\n\n\n\n\n\nHomogeneous\nHeterogeneous\n\n\n\n\n1d\natomic vector\nlist\n\n\n2d\nmatrix\ndata.frame\n\n\nnd\narray\n\n\n\n\n\nLet’s take a closer look at the two we will use mostly throughout this workshop:\n\n\nAtomic vectors (from hereon only called vectors) contain elements of only the same type:\n\nnum_vec &lt;- c(2023, 8, 8)\nnum_vec\n\n[1] 2023    8    8\n\nchar_vec &lt;- c(\"This\", \"is\", \"a\", \"vec\", \".\")\nchar_vec\n\n[1] \"This\" \"is\"   \"a\"    \"vec\"  \".\"   \n\nlog_vec &lt;- c(TRUE, FALSE)\nlog_vec\n\n[1]  TRUE FALSE\n\n\nThe c() stands for combine, or concatenate, and is the basic function for building a vector out of single elements.\n\n\nIf we take a look at the structure of the vectors we have just created, we see se a short description of the data type we are dealing with in front of the vector:\n\nstr(num_vec)\n\n num [1:3] 2023 8 8\n\nstr(char_vec)\n\n chr [1:5] \"This\" \"is\" \"a\" \"vec\" \".\"\n\nstr(log_vec)\n\n logi [1:2] TRUE FALSE\n\n\nThe first one is num (numeric) so it only stores numeric values. The second one is char (character), so it only can contain strings. And last but not least we have logi (logical) for boolean values. Why is that important? Well, some functions only make sense for specific data types. For example:\n\nmean(char_vec)\n\nWarning in mean.default(char_vec): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\ngives us a warning, because the input has the wrong format.\n\n\n\n\nA data frame is two dimensional and can store elements of different types. It is the closest to data tables we are probably most used to working with.\n\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n\nNote that we do nothing else here than combining vectors to a data frame. Each vector will be one column.\n\n\nA special type of data frames are the so called tibbles. Tibbles are a modern version of data frames and the standard data frame type of the tidyverse, as they have some advantageous characteristics (e.g., note the prettier printing of the data frame). So don’t be confused if you run into them, in general they behave like data frames.\n\npersons_tibble &lt;- tibble::tibble(\n  name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n  age = c(19, 17, 18, 18),\n  birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n  big5_extro = c(3.5, 2, 4.5, 4.2)\n)\npersons_tibble\n\n# A tibble: 4 × 4\n  name    age birth_month big5_extro\n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1 Anna     19 Jan                3.5\n2 Alex     17 Sep                2  \n3 John     18 Oct                4.5\n4 Jessi    18 Mar                4.2\n\n\n\n\n\n\nA list is a one dimensional object, which can, unlike like a vector, contain elements of different types, but also of different lengths. For example, we can store a vectors of different lengths and data frames in a list, which makes it the most versatile data structure:\n\npersonality_rating &lt;- list(\n     big5 = data.frame(name = c(\"Jessi\", \"John\"),\n                       extraversion = c(4.3, 2), \n                       openness = c(3.8, NA)),\n     rating_type = \"self_rating\"\n     )\npersonality_rating\n\n$big5\n   name extraversion openness\n1 Jessi          4.3      3.8\n2  John          2.0       NA\n\n$rating_type\n[1] \"self_rating\"\n\n\nHere, we define the list personality_rating, which includes a data frame with the personality rating, and some meta information in the form of a character vector, describing the rating type. We won’t use it any more in this workshop, but keep in mind it exists, as it quickly becomes necessary for managing more complex tasks.\nInstead, we are now well equipped to get started with some data manipulation and transformation."
  },
  {
    "objectID": "qmd/data_structures/data_structures.html#vector",
    "href": "qmd/data_structures/data_structures.html#vector",
    "title": "Data structures",
    "section": "",
    "text": "Atomic vectors (from hereon only called vectors) contain elements of only the same type:\n\nnum_vec &lt;- c(2023, 8, 8)\nnum_vec\n\n[1] 2023    8    8\n\nchar_vec &lt;- c(\"This\", \"is\", \"a\", \"vec\", \".\")\nchar_vec\n\n[1] \"This\" \"is\"   \"a\"    \"vec\"  \".\"   \n\nlog_vec &lt;- c(TRUE, FALSE)\nlog_vec\n\n[1]  TRUE FALSE\n\n\nThe c() stands for combine, or concatenate, and is the basic function for building a vector out of single elements.\n\n\nIf we take a look at the structure of the vectors we have just created, we see se a short description of the data type we are dealing with in front of the vector:\n\nstr(num_vec)\n\n num [1:3] 2023 8 8\n\nstr(char_vec)\n\n chr [1:5] \"This\" \"is\" \"a\" \"vec\" \".\"\n\nstr(log_vec)\n\n logi [1:2] TRUE FALSE\n\n\nThe first one is num (numeric) so it only stores numeric values. The second one is char (character), so it only can contain strings. And last but not least we have logi (logical) for boolean values. Why is that important? Well, some functions only make sense for specific data types. For example:\n\nmean(char_vec)\n\nWarning in mean.default(char_vec): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\ngives us a warning, because the input has the wrong format."
  },
  {
    "objectID": "qmd/data_structures/data_structures.html#data-frame",
    "href": "qmd/data_structures/data_structures.html#data-frame",
    "title": "Data structures",
    "section": "",
    "text": "A data frame is two dimensional and can store elements of different types. It is the closest to data tables we are probably most used to working with.\n\npersons &lt;- data.frame(name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n                      age = c(19, 17, 18, 18),\n                      birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n                      big5_extro = c(3.5, 2, 4.5, 4.2)\n                      )\n\nNote that we do nothing else here than combining vectors to a data frame. Each vector will be one column.\n\n\nA special type of data frames are the so called tibbles. Tibbles are a modern version of data frames and the standard data frame type of the tidyverse, as they have some advantageous characteristics (e.g., note the prettier printing of the data frame). So don’t be confused if you run into them, in general they behave like data frames.\n\npersons_tibble &lt;- tibble::tibble(\n  name = c(\"Anna\", \"Alex\", \"John\", \"Jessi\"),\n  age = c(19, 17, 18, 18),\n  birth_month = c(\"Jan\", \"Sep\", \"Oct\", \"Mar\"),\n  big5_extro = c(3.5, 2, 4.5, 4.2)\n)\npersons_tibble\n\n# A tibble: 4 × 4\n  name    age birth_month big5_extro\n  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1 Anna     19 Jan                3.5\n2 Alex     17 Sep                2  \n3 John     18 Oct                4.5\n4 Jessi    18 Mar                4.2"
  },
  {
    "objectID": "qmd/data_structures/data_structures.html#honorable-mention-list",
    "href": "qmd/data_structures/data_structures.html#honorable-mention-list",
    "title": "Data structures",
    "section": "",
    "text": "A list is a one dimensional object, which can, unlike like a vector, contain elements of different types, but also of different lengths. For example, we can store a vectors of different lengths and data frames in a list, which makes it the most versatile data structure:\n\npersonality_rating &lt;- list(\n     big5 = data.frame(name = c(\"Jessi\", \"John\"),\n                       extraversion = c(4.3, 2), \n                       openness = c(3.8, NA)),\n     rating_type = \"self_rating\"\n     )\npersonality_rating\n\n$big5\n   name extraversion openness\n1 Jessi          4.3      3.8\n2  John          2.0       NA\n\n$rating_type\n[1] \"self_rating\"\n\n\nHere, we define the list personality_rating, which includes a data frame with the personality rating, and some meta information in the form of a character vector, describing the rating type. We won’t use it any more in this workshop, but keep in mind it exists, as it quickly becomes necessary for managing more complex tasks.\nInstead, we are now well equipped to get started with some data manipulation and transformation."
  },
  {
    "objectID": "qmd/data_structures/data_structures.html#footnotes",
    "href": "qmd/data_structures/data_structures.html#footnotes",
    "title": "Data structures",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTable from Advanced R.↩︎"
  },
  {
    "objectID": "qmd/load_data/load_data.html",
    "href": "qmd/load_data/load_data.html",
    "title": "Load data",
    "section": "",
    "text": "There are many different data types out there, of which many can be loaded into R. Depending on the type, different commands are used within R. Sometimes, we will have to use additional packages to get access to that function, mainly readxl and haven.\n\n\n\n\n\n\n\n\n\nData.type\nImport\nExport\n\n\n\n\nR objects (.Rdata, .rda)\nload()\nsave()\n\n\nsingle R object (.Rds)\nreadRDS()\nsaveRDS()\n\n\ntext-files (.txt)\nread.table()\nwrite.table()\n\n\n.csv-files (.csv)\nread.csv()\nwrite.csv()\n\n\nExcel-files (.xlsx)\nreadxl::read_excel()\nwritexl::write_xlsx()\n\n\nSPSS-files (.sav)\nhaven::read_sav()\nhaven::write_sav()\n\n\nSAS-files (.sas)\nhaven::read_sas()\nhaven::write_sas()\n\n\nStata-files (.stata)\nhaven::read_dta()\nhaven::write_dta()\n\n\n\n\n\n\n\nYou can head to a specific file by using the full path (absolute path): \"C:\\Users\\hafiznij\\Documents\\GitHub\\r_tutorial\\raw_data\\winners.rda\". This approach has some disadvantages: it will only work on my notebook. If i want to continue my project on another device, i will have to change the path. The same goes for other people who want to work with my project. So, to keep these paths more reproducable, we should always use relative paths if possible: \".\\raw_data\\winners.rda\". This will always work independently of the device i am working on, as long as i am in the correct working directory.\nThe working directory is the path R is currently working in. I can obtain it by typing:\n\ngetwd()\n\n[1] \"/home/runner/work/r_tutorial/r_tutorial/qmd/load_data\"\n\n\nLuckily, as long as we work with RStudio projects, we don’t have to deal with that, as the working directory is set automatically by the project.\nNow take a look at the working directory and the relative path i used for loading the winners.rda. Notice something? Correct, both paths combined equal the absolute path to the file. So by splitting it up, we obtain a more reproducible path, that works independent of where the current working directory is.\n\n\n\nAnother great way to deal with the path confusion is to use the here package. It can build the paths relative to the directory where your RStudio project is saved in. For example, \".\\raw_data\\winners.rda\" becomes here::here(\"raw_data\", \"winners.rda\"). This is not increadibly important right now, but I need to mention it because I have to use these path structures sometimes during the tutorial, so don’t be confused! It is just another way to build file paths. Look here (:D) if you want to learn more about the package."
  },
  {
    "objectID": "qmd/load_data/load_data.html#data-types",
    "href": "qmd/load_data/load_data.html#data-types",
    "title": "Load data",
    "section": "",
    "text": "There are many different data types out there, of which many can be loaded into R. Depending on the type, different commands are used within R. Sometimes, we will have to use additional packages to get access to that function, mainly readxl and haven.\n\n\n\n\n\n\n\n\n\nData.type\nImport\nExport\n\n\n\n\nR objects (.Rdata, .rda)\nload()\nsave()\n\n\nsingle R object (.Rds)\nreadRDS()\nsaveRDS()\n\n\ntext-files (.txt)\nread.table()\nwrite.table()\n\n\n.csv-files (.csv)\nread.csv()\nwrite.csv()\n\n\nExcel-files (.xlsx)\nreadxl::read_excel()\nwritexl::write_xlsx()\n\n\nSPSS-files (.sav)\nhaven::read_sav()\nhaven::write_sav()\n\n\nSAS-files (.sas)\nhaven::read_sas()\nhaven::write_sas()\n\n\nStata-files (.stata)\nhaven::read_dta()\nhaven::write_dta()"
  },
  {
    "objectID": "qmd/load_data/load_data.html#absolute-paths-vs.-relative-paths",
    "href": "qmd/load_data/load_data.html#absolute-paths-vs.-relative-paths",
    "title": "Load data",
    "section": "",
    "text": "You can head to a specific file by using the full path (absolute path): \"C:\\Users\\hafiznij\\Documents\\GitHub\\r_tutorial\\raw_data\\winners.rda\". This approach has some disadvantages: it will only work on my notebook. If i want to continue my project on another device, i will have to change the path. The same goes for other people who want to work with my project. So, to keep these paths more reproducable, we should always use relative paths if possible: \".\\raw_data\\winners.rda\". This will always work independently of the device i am working on, as long as i am in the correct working directory.\nThe working directory is the path R is currently working in. I can obtain it by typing:\n\ngetwd()\n\n[1] \"/home/runner/work/r_tutorial/r_tutorial/qmd/load_data\"\n\n\nLuckily, as long as we work with RStudio projects, we don’t have to deal with that, as the working directory is set automatically by the project.\nNow take a look at the working directory and the relative path i used for loading the winners.rda. Notice something? Correct, both paths combined equal the absolute path to the file. So by splitting it up, we obtain a more reproducible path, that works independent of where the current working directory is."
  },
  {
    "objectID": "qmd/load_data/load_data.html#the-here-package",
    "href": "qmd/load_data/load_data.html#the-here-package",
    "title": "Load data",
    "section": "",
    "text": "Another great way to deal with the path confusion is to use the here package. It can build the paths relative to the directory where your RStudio project is saved in. For example, \".\\raw_data\\winners.rda\" becomes here::here(\"raw_data\", \"winners.rda\"). This is not increadibly important right now, but I need to mention it because I have to use these path structures sometimes during the tutorial, so don’t be confused! It is just another way to build file paths. Look here (:D) if you want to learn more about the package."
  },
  {
    "objectID": "qmd/subsetting/subsetting.html",
    "href": "qmd/subsetting/subsetting.html",
    "title": "Subsetting data",
    "section": "",
    "text": "## Extract elements from a vector\nvec_athlete[c(2, 3, 4)]\n\n## Extract rows and columns by position and name:\nwinners[c(1, 4), c(\"Year\", \"Nationality\")]\n\n## Conditional subsetting of rows:\nwinners[winners$Nationality == \"Kenya\" & winners$Year &lt; 2000, ]\n\n\n\nlibrary(dplyr)\n\n## conditional subsetting of rows\nfilter(winners, Nationality == \"Kenya\", Year &lt; 2000)\n\n## selecting columns\nselect(winners, Year, Athlete)\n\n## pipe operator %&gt;% \nwinners %&gt;%\n  filter(Nationality == \"Kenya\", Year &lt; 2000)\n  select(Year, Athlete)\n\n\nLet’s take a closer look at these commands and see them in action!\n\n\n\n1\nLoad the data set, which lies within the folder raw_data in my working directory:\n\nwinners &lt;- readRDS(file = here::here(\"raw_data\", \"winners.rds\"))\n\nLet’s take a quick look:\n\nhead(winners)\n\n  Category Year              Athlete    Nationality Hours Minutes Seconds\n1      Men 1981 Dick Beardsley (Tie)  United States     2      11      48\n2      Men 1981  Inge Simonsen (Tie)         Norway    NA      11      48\n3      Men 1982           Hugh Jones United Kingdom     2       9      24\n4      Men 1983         Mike Gratton United Kingdom     2       9      43\n5      Men 1984     Charlie Spedding United Kingdom    NA       9      57\n6      Men 1985          Steve Jones United Kingdom     2       8      16\n\n\nSo, this data frame seems to hold the winners of the london marathon. Now we want to look at how we can extract data from our data structures, so we can work with it.\n\n\n\nWe will look at two ways to extract rows and columns from data frames.\n\n\nIn Base R, we use square brackets [,] to extract specific rows and columns.\n\n\n\nIn front of the , we write the rows we want to extract:\n\n# Extract the first and the fourth row\nwinners[c(1, 4), ]\n\n  Category Year              Athlete    Nationality Hours Minutes Seconds\n1      Men 1981 Dick Beardsley (Tie)  United States     2      11      48\n4      Men 1983         Mike Gratton United Kingdom     2       9      43\n\n\n\n\nBehind it the columns:\n\n# Extract the second and the fourth column:\nwinners[, c(2, 4)]\n\n    Year    Nationality\n1   1981  United States\n2   1981         Norway\n3   1982 United Kingdom\n...\n\n# Extract the columns by name:\nwinners[, c(\"Year\", \"Nationality\")]\n\n    Year    Nationality\n1   1981  United States\n2   1981         Norway\n3   1982 United Kingdom\n...\n\n# Or only the column Year (and turn it into a vector right away):\nwinners$Year\n\n  [1] 1981 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994\n [16] 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009\n [31] 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 1981\n [46] 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996\n...\n\n\nSuggestion: Always use column names instead of position if possible. This way, your code will still work if the column position changes.\n\n\n\nAnd of course we can combine both calls:\n\nwinners[c(1, 4), c(2, 4)]\n\n  Year    Nationality\n1 1981  United States\n4 1983 United Kingdom\n\nwinners[c(1, 4), c(\"Year\", \"Nationality\")]\n\n  Year    Nationality\n1 1981  United States\n4 1983 United Kingdom\n\n\nWe can also use Boolean values (every row/column must get a value here, so we extract the first 100 rows by repeating TRUE 100 times, and than add FALSE for the remaining rows):\n\nstr(winners[c(rep(TRUE, 100), rep(FALSE, 65)), c(TRUE, FALSE, FALSE, TRUE, TRUE)])\n\n'data.frame':   100 obs. of  4 variables:\n $ Category   : chr  \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Nationality: chr  \"United States\" \"Norway\" \"United Kingdom\" \"United Kingdom\" ...\n $ Hours      : num  2 NA 2 2 NA 2 2 NA 2 2 ...\n $ Minutes    : num  11 11 9 9 9 8 10 9 10 9 ...\n\n\n\n\n\nNow the stuff we looked at in logical operators comes in handy! We can filter rows which match some condition. For example, we might want to look at all winners from Kenya:\n\nwinners[winners$Nationality == \"Kenya\", ]\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n26      Men 2005                 Martin Lel       Kenya     2       7      35\n...\n\n\nTake a close look at the comparison before the ,:\n\nwinners$Nationality == \"Kenya\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n...\n\n\nwinners$Nationality is a vector, so comparing its values to a specified value yields a logical vector with the respective TRUE and FALSE values. We can insert this logical vector in front of the , to extract all rows corresponding to that condition.\nIf we want to extract multiple nationalities at once, we need the %in% operator:\n\nwinners[winners$Nationality %in% c(\"Kenya\", \"Germany\", \"Norway\"), ]\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n2       Men 1981        Inge Simonsen (Tie)      Norway    NA      11      48\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n...\n\n\nBy the way, if we want to save our extracted data frame, we can assign it a new name (otherwise it will only get printed into the console, but we can’t go on working with it):\n\nwinners_nat &lt;- winners[winners$Nationality %in% c(\"Kenya\", \"Germany\", \"Norway\"), ]\nwinners_nat\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n2       Men 1981        Inge Simonsen (Tie)      Norway    NA      11      48\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n...\n\n\nWe can also combine multiple logical vectors using & (“and”) and | (“or”). For example, we might want to look at all Kenyan winners before the year 2000:\n\nwinners[winners$Nationality == \"Kenya\" & winners$Year &lt; 2000, ]\n\n   Category Year           Athlete Nationality Hours Minutes Seconds\n10      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n61    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n63    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\nOr at all women winners from Australia in the wheelchair category, and the male winners from the United States in the wheelchair category:\n\nwinners[(winners$Category == \"Wheelchair Women\" & winners$Nationality == \"Australia\") | (winners$Category == \"Wheelchair Men\" & winners$Nationality == \"United States\"), ]\n\n            Category Year            Athlete   Nationality Hours Minutes\n120   Wheelchair Men 2015        Josh George United States     1      31\n124   Wheelchair Men 2019   Daniel Romanchuk United States     1      33\n162 Wheelchair Women 2018 Madison de Rozario     Australia     1      42\n...\n\n\nIn the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Enter, the filter() function:\n\n\n\n\nThe dplyr package is part of the tidyverse and provides a grammar of data manipulation. We can use filter() to subset rows from a data frame:\n\n\n\n\nlibrary(dplyr)\n\nfilter(winners, Nationality == \"Kenya\", Year &lt; 2000)\n\n  Category Year           Athlete Nationality Hours Minutes Seconds\n1      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n2    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n3    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\n\nNote how we can just write our conditions without connecting them with & (filter() does that automatically for us). Also, we don’t have to put the column names into \"\", because filter() knows that this are column names of the winners data frame, which makes coding a bit more pleasant.\n\n\n\nFor extracting columns, we need select():\n\n\nselect(winners, Year, Athlete)\n\n    Year                    Athlete\n1   1981       Dick Beardsley (Tie)\n2   1981        Inge Simonsen (Tie)\n3   1982                 Hugh Jones\n...\n\n\n\n\n\n\nHold on! Normally, we wouldn’t write tidyverse code like that. Instead, we would use the pipe operator %&gt;% (than do), which makes it easy to connect multiple function calls:\n\n\nwinners %&gt;%\n  filter(Nationality == \"Kenya\", Year &lt; 2000)\n\n  Category Year           Athlete Nationality Hours Minutes Seconds\n1      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n2    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n3    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\n\nHere, we first input the data frame we want to manipulate. Than we filter, as specified by the pipe operator. Like this, we can easily connect multiple function calls instead of nesting them within multiple brackets, which increases the readability:\n\nwinners[winners$Year &gt; 2000 & winners$Category == \"Women\", c(\"Category\", \"Year\")]\n\n   Category Year\n65    Women 2001\n66    Women 2002\n67    Women 2003\n...\n\n\nbecomes:\n\n\nwinners %&gt;%\n  filter(Year &gt; 2000, Category == \"Women\") %&gt;%\n  select(Category, Year)\n\n   Category Year\n1     Women 2001\n2     Women 2002\n3     Women 2003\n...\n\n\n\nMuch nicer to read, right?\nSome notes on this syntax: 1. If we don’t have any additional arguments we want to put into the function, we can just write the function name without any brackets. 1. The pipe operator will give the result of the last function as input into the next function. 1. If we want to clearly state which of the function arguments should receive the input, we can write a ., which can be read as output of the previous function call.\n\n\n\n\n\nFinally, let’s take a quick look at how to extract elements from a vector, which shouldn’t be a problem after already dealing with data frames. It’s pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets. Let’s quickly define a vector for illustration:\n\nvec_athlete &lt;- winners$Athlete # remember: `$` returns a vector\n\nAnd look at the second element:\n\nvec_athlete[2]\n\n[1] \"Inge Simonsen (Tie)\"\n\n\nOf course we can also do that for multiple elements:\n\nvec_athlete[c(2, 3, 4)]\n\n[1] \"Inge Simonsen (Tie)\" \"Hugh Jones\"          \"Mike Gratton\"       \n\n## Or, less to write:\nvec_athlete[2:4]\n\n[1] \"Inge Simonsen (Tie)\" \"Hugh Jones\"          \"Mike Gratton\"       \n\n\nAnother way would be to provide a logical vector, which defines for each position if we want to extract the element or not (like we already did for data frames):\n\nvec_athlete[c(rep(TRUE, 100), rep(FALSE, 65))]\n\n  [1] \"Dick Beardsley (Tie)\"       \"Inge Simonsen (Tie)\"       \n  [3] \"Hugh Jones\"                 \"Mike Gratton\"              \n  [5] \"Charlie Spedding\"           \"Steve Jones\"               \n  [7] \"Toshihiko Seko\"             \"Hiromi Taniguchi\"          \n...\n\n\n\n\n\n\nLoad the tutoR package and start the exercise by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"subsetting\", package = \"tutoR\")"
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#overview-of-the-main-commands-in-this-section",
    "href": "qmd/subsetting/subsetting.html#overview-of-the-main-commands-in-this-section",
    "title": "Subsetting data",
    "section": "",
    "text": "## Extract elements from a vector\nvec_athlete[c(2, 3, 4)]\n\n## Extract rows and columns by position and name:\nwinners[c(1, 4), c(\"Year\", \"Nationality\")]\n\n## Conditional subsetting of rows:\nwinners[winners$Nationality == \"Kenya\" & winners$Year &lt; 2000, ]\n\n\n\nlibrary(dplyr)\n\n## conditional subsetting of rows\nfilter(winners, Nationality == \"Kenya\", Year &lt; 2000)\n\n## selecting columns\nselect(winners, Year, Athlete)\n\n## pipe operator %&gt;% \nwinners %&gt;%\n  filter(Nationality == \"Kenya\", Year &lt; 2000)\n  select(Year, Athlete)\n\n\nLet’s take a closer look at these commands and see them in action!"
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#data-set",
    "href": "qmd/subsetting/subsetting.html#data-set",
    "title": "Subsetting data",
    "section": "",
    "text": "1\nLoad the data set, which lies within the folder raw_data in my working directory:\n\nwinners &lt;- readRDS(file = here::here(\"raw_data\", \"winners.rds\"))\n\nLet’s take a quick look:\n\nhead(winners)\n\n  Category Year              Athlete    Nationality Hours Minutes Seconds\n1      Men 1981 Dick Beardsley (Tie)  United States     2      11      48\n2      Men 1981  Inge Simonsen (Tie)         Norway    NA      11      48\n3      Men 1982           Hugh Jones United Kingdom     2       9      24\n4      Men 1983         Mike Gratton United Kingdom     2       9      43\n5      Men 1984     Charlie Spedding United Kingdom    NA       9      57\n6      Men 1985          Steve Jones United Kingdom     2       8      16\n\n\nSo, this data frame seems to hold the winners of the london marathon. Now we want to look at how we can extract data from our data structures, so we can work with it."
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#data-frames",
    "href": "qmd/subsetting/subsetting.html#data-frames",
    "title": "Subsetting data",
    "section": "",
    "text": "We will look at two ways to extract rows and columns from data frames.\n\n\nIn Base R, we use square brackets [,] to extract specific rows and columns.\n\n\n\nIn front of the , we write the rows we want to extract:\n\n# Extract the first and the fourth row\nwinners[c(1, 4), ]\n\n  Category Year              Athlete    Nationality Hours Minutes Seconds\n1      Men 1981 Dick Beardsley (Tie)  United States     2      11      48\n4      Men 1983         Mike Gratton United Kingdom     2       9      43\n\n\n\n\nBehind it the columns:\n\n# Extract the second and the fourth column:\nwinners[, c(2, 4)]\n\n    Year    Nationality\n1   1981  United States\n2   1981         Norway\n3   1982 United Kingdom\n...\n\n# Extract the columns by name:\nwinners[, c(\"Year\", \"Nationality\")]\n\n    Year    Nationality\n1   1981  United States\n2   1981         Norway\n3   1982 United Kingdom\n...\n\n# Or only the column Year (and turn it into a vector right away):\nwinners$Year\n\n  [1] 1981 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994\n [16] 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009\n [31] 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 1981\n [46] 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996\n...\n\n\nSuggestion: Always use column names instead of position if possible. This way, your code will still work if the column position changes.\n\n\n\nAnd of course we can combine both calls:\n\nwinners[c(1, 4), c(2, 4)]\n\n  Year    Nationality\n1 1981  United States\n4 1983 United Kingdom\n\nwinners[c(1, 4), c(\"Year\", \"Nationality\")]\n\n  Year    Nationality\n1 1981  United States\n4 1983 United Kingdom\n\n\nWe can also use Boolean values (every row/column must get a value here, so we extract the first 100 rows by repeating TRUE 100 times, and than add FALSE for the remaining rows):\n\nstr(winners[c(rep(TRUE, 100), rep(FALSE, 65)), c(TRUE, FALSE, FALSE, TRUE, TRUE)])\n\n'data.frame':   100 obs. of  4 variables:\n $ Category   : chr  \"Men\" \"Men\" \"Men\" \"Men\" ...\n $ Nationality: chr  \"United States\" \"Norway\" \"United Kingdom\" \"United Kingdom\" ...\n $ Hours      : num  2 NA 2 2 NA 2 2 NA 2 2 ...\n $ Minutes    : num  11 11 9 9 9 8 10 9 10 9 ...\n\n\n\n\n\nNow the stuff we looked at in logical operators comes in handy! We can filter rows which match some condition. For example, we might want to look at all winners from Kenya:\n\nwinners[winners$Nationality == \"Kenya\", ]\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n26      Men 2005                 Martin Lel       Kenya     2       7      35\n...\n\n\nTake a close look at the comparison before the ,:\n\nwinners$Nationality == \"Kenya\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n...\n\n\nwinners$Nationality is a vector, so comparing its values to a specified value yields a logical vector with the respective TRUE and FALSE values. We can insert this logical vector in front of the , to extract all rows corresponding to that condition.\nIf we want to extract multiple nationalities at once, we need the %in% operator:\n\nwinners[winners$Nationality %in% c(\"Kenya\", \"Germany\", \"Norway\"), ]\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n2       Men 1981        Inge Simonsen (Tie)      Norway    NA      11      48\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n...\n\n\nBy the way, if we want to save our extracted data frame, we can assign it a new name (otherwise it will only get printed into the console, but we can’t go on working with it):\n\nwinners_nat &lt;- winners[winners$Nationality %in% c(\"Kenya\", \"Germany\", \"Norway\"), ]\nwinners_nat\n\n   Category Year                    Athlete Nationality Hours Minutes Seconds\n2       Men 1981        Inge Simonsen (Tie)      Norway    NA      11      48\n10      Men 1989          Douglas Wakiihuri       Kenya     2       9       3\n25      Men 2004                Evans Rutto       Kenya     2       6      18\n...\n\n\nWe can also combine multiple logical vectors using & (“and”) and | (“or”). For example, we might want to look at all Kenyan winners before the year 2000:\n\nwinners[winners$Nationality == \"Kenya\" & winners$Year &lt; 2000, ]\n\n   Category Year           Athlete Nationality Hours Minutes Seconds\n10      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n61    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n63    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\nOr at all women winners from Australia in the wheelchair category, and the male winners from the United States in the wheelchair category:\n\nwinners[(winners$Category == \"Wheelchair Women\" & winners$Nationality == \"Australia\") | (winners$Category == \"Wheelchair Men\" & winners$Nationality == \"United States\"), ]\n\n            Category Year            Athlete   Nationality Hours Minutes\n120   Wheelchair Men 2015        Josh George United States     1      31\n124   Wheelchair Men 2019   Daniel Romanchuk United States     1      33\n162 Wheelchair Women 2018 Madison de Rozario     Australia     1      42\n...\n\n\nIn the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Enter, the filter() function:\n\n\n\n\nThe dplyr package is part of the tidyverse and provides a grammar of data manipulation. We can use filter() to subset rows from a data frame:\n\n\n\n\nlibrary(dplyr)\n\nfilter(winners, Nationality == \"Kenya\", Year &lt; 2000)\n\n  Category Year           Athlete Nationality Hours Minutes Seconds\n1      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n2    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n3    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\n\nNote how we can just write our conditions without connecting them with & (filter() does that automatically for us). Also, we don’t have to put the column names into \"\", because filter() knows that this are column names of the winners data frame, which makes coding a bit more pleasant.\n\n\n\nFor extracting columns, we need select():\n\n\nselect(winners, Year, Athlete)\n\n    Year                    Athlete\n1   1981       Dick Beardsley (Tie)\n2   1981        Inge Simonsen (Tie)\n3   1982                 Hugh Jones\n...\n\n\n\n\n\n\nHold on! Normally, we wouldn’t write tidyverse code like that. Instead, we would use the pipe operator %&gt;% (than do), which makes it easy to connect multiple function calls:\n\n\nwinners %&gt;%\n  filter(Nationality == \"Kenya\", Year &lt; 2000)\n\n  Category Year           Athlete Nationality Hours Minutes Seconds\n1      Men 1989 Douglas Wakiihuri       Kenya     2       9       3\n2    Women 1997  Joyce Chepchumba       Kenya     2      26      51\n3    Women 1999  Joyce Chepchumba       Kenya     2      23      22\n\n\n\nHere, we first input the data frame we want to manipulate. Than we filter, as specified by the pipe operator. Like this, we can easily connect multiple function calls instead of nesting them within multiple brackets, which increases the readability:\n\nwinners[winners$Year &gt; 2000 & winners$Category == \"Women\", c(\"Category\", \"Year\")]\n\n   Category Year\n65    Women 2001\n66    Women 2002\n67    Women 2003\n...\n\n\nbecomes:\n\n\nwinners %&gt;%\n  filter(Year &gt; 2000, Category == \"Women\") %&gt;%\n  select(Category, Year)\n\n   Category Year\n1     Women 2001\n2     Women 2002\n3     Women 2003\n...\n\n\n\nMuch nicer to read, right?\nSome notes on this syntax: 1. If we don’t have any additional arguments we want to put into the function, we can just write the function name without any brackets. 1. The pipe operator will give the result of the last function as input into the next function. 1. If we want to clearly state which of the function arguments should receive the input, we can write a ., which can be read as output of the previous function call."
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#vectors",
    "href": "qmd/subsetting/subsetting.html#vectors",
    "title": "Subsetting data",
    "section": "",
    "text": "Finally, let’s take a quick look at how to extract elements from a vector, which shouldn’t be a problem after already dealing with data frames. It’s pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets. Let’s quickly define a vector for illustration:\n\nvec_athlete &lt;- winners$Athlete # remember: `$` returns a vector\n\nAnd look at the second element:\n\nvec_athlete[2]\n\n[1] \"Inge Simonsen (Tie)\"\n\n\nOf course we can also do that for multiple elements:\n\nvec_athlete[c(2, 3, 4)]\n\n[1] \"Inge Simonsen (Tie)\" \"Hugh Jones\"          \"Mike Gratton\"       \n\n## Or, less to write:\nvec_athlete[2:4]\n\n[1] \"Inge Simonsen (Tie)\" \"Hugh Jones\"          \"Mike Gratton\"       \n\n\nAnother way would be to provide a logical vector, which defines for each position if we want to extract the element or not (like we already did for data frames):\n\nvec_athlete[c(rep(TRUE, 100), rep(FALSE, 65))]\n\n  [1] \"Dick Beardsley (Tie)\"       \"Inge Simonsen (Tie)\"       \n  [3] \"Hugh Jones\"                 \"Mike Gratton\"              \n  [5] \"Charlie Spedding\"           \"Steve Jones\"               \n  [7] \"Toshihiko Seko\"             \"Hiromi Taniguchi\"          \n..."
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#exercises",
    "href": "qmd/subsetting/subsetting.html#exercises",
    "title": "Subsetting data",
    "section": "",
    "text": "Load the tutoR package and start the exercise by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"subsetting\", package = \"tutoR\")"
  },
  {
    "objectID": "qmd/subsetting/subsetting.html#footnotes",
    "href": "qmd/subsetting/subsetting.html#footnotes",
    "title": "Subsetting data",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nImage by Miguel A Amutio on Unsplash.↩︎"
  },
  {
    "objectID": "qmd/plotting/plotting.html",
    "href": "qmd/plotting/plotting.html",
    "title": "R - Open Research Summer School",
    "section": "",
    "text": "This section is for more experienced R users who want to start plotting with ggplot2. It is not necessary to follow the rest of the conference.\nThis is Zusatz. Plot world map with the winning countries, the more the darker. Same colours for same continents."
  },
  {
    "objectID": "qmd/load_data/load_data_exercise.html",
    "href": "qmd/load_data/load_data_exercise.html",
    "title": "Exercises",
    "section": "",
    "text": "Exercises\n\nFor the rest of the workshop, we will use the data frame winners from the package LondonMarathon. I have already tweaked it a bit to make it easier to work with, so just download it from here and load it into R (write the code for reading in the data into a new script).\nAdvanced: Load the continents.csv file into R. Did that work as expected? If not, why not? (Solution) Hint: Take a look at the .csv by opening it in a text editor. Look at the documentation of read.csv() and take a look at the sep argument.\n\n\n\nSolution\n\nwinners &lt;- readRDS(file = here::here(\"raw_data\", \"winners.rds\"))\n\n\n\nSolution for exercise 1\nwinners &lt;- readRDS(file = \"./raw_data/winners.rds\")\n\n\n\n\nSolution for exercise 2\ncontinents &lt;- read.csv(file = \"./raw_data/continents.csv\")\n\nhead(continents)\n \n# Hmm that looks weird. If we take a look at the file by opening it in a text editor, we can see that the values are seperated by `;`. \n# So let's call the help for `read.csv()`:\n\n?read.csv\n\n# The `sep` argument specifies that the seperator needs to be a white space (meaning tabs, spaces ... - look at the details).  \n# So, we can do the following:\n\ncontinents &lt;- read.csv(\n  file = \"./raw_data/continents.csv\",\n  sep = \";\"\n)\n\nhead(continents)\n\n# This looks better! Now we can merge both data sets, so we can actually work with them."
  },
  {
    "objectID": "qmd/packages/packages.html",
    "href": "qmd/packages/packages.html",
    "title": "Packages",
    "section": "",
    "text": "Packages are extensions to the base R you get by default. Most times they provide many new functions, bundled around a specific use case. When working with R you will have to rely heavily on packages developed by others. There are many, many great packages out there facilitating your work with R and making possible many different analyses, visualizations and many more.\nWe can compare them somewhat to apps in an appstore:\n1 First, we have to install the package: install.packages(\"packagename\"). - Most of the openly available packages lie on CRAN (Comprehensive R Archive Network). But you can also download packages form other sources, for example GitHub. This is what you did when downloading the tutoR package in About this workshop.\n2 Then, we have to load them in each session where we want to use them (like tipping on the app icon): library(packagename).\n\nNote that in install.packages(\"packagename\") we have to put the package into quotation marks, when calling library(packagename) not.\n\n\n\nBefore we can use packages we have to install them once. Most packages are hosted via the Comprehensive R Archive Network (CRAN), to install a package from there, we can use:\n\ninstall.packages(\"aRtsy\")\n\nBut often packages are only (or as well) provided via GitHub. To install a package from there, use:\n\ndevtools::install_github(\"cutterkom/generativeart\")\n\n\n\n\nAfter installing a package, we have to load it into our R session:\n\n#library(aRtsy)\n\nNow we are free to use it, in this case to generate some artwork:\n\n#set.seed(1)\n#canvas_collatz(colors = colorPalette(\"lava\"))\n\n\n\n\n\n\n\n\n\n\nExpand to learn about dealing with identical function names from different packages\n\n\n\n\n\nOf course it can happen that different packages include functions with the same name. For example, look at the warnings we get when installing and then loading the packages ggplot2 and psych:\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"psych\")\n\n\nlibrary(ggplot2)\nlibrary(psych)\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n\n\nThere seems to be a function named alpha which is included in both packages (but not the same function, just the same name). The warning message notifies us that the object alpha from ggplot2 is masked, so if we call it, the alpha function from the psych package is used. To solve that quandary, we can use the :: operator. In front we write the package name, and behind it the name of the function we want to use from that package:\n\nggplot2::alpha()\npsych::alpha()\n\n\n\n\n\n\n\n\n\n\n\n\n\nExpand to learn about managing package versions\n\n\n\n\n\nFinally, a quick note on package management and reproducability of your code. R versions and package versions will change over time, in which case also the output of your code might change. Therefore, it is good practice to save the R version and package versions, so your code stays (kind of) reproducable for a longer period of time. The most straight forward thing to do is to just write down your R-version and the package versions at the top of your script. Call the versions you use with:\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] psych_2.3.6   ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       nlme_3.1-162      cli_3.6.1         knitr_1.43       \n [5] rlang_1.1.1       xfun_0.39         generics_0.1.3    renv_1.0.0       \n [9] jsonlite_1.8.7    glue_1.6.2        colorspace_2.1-0  htmltools_0.5.5  \n[13] scales_1.2.1      fansi_1.0.4       rmarkdown_2.23    grid_4.3.1       \n[17] evaluate_0.21     munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1    \n[21] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    dplyr_1.1.2      \n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 lattice_0.21-8    digest_0.6.32    \n[29] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        parallel_4.3.1   \n[33] mnormt_2.1.1      pillar_1.9.0      magrittr_2.0.3    withr_2.5.0      \n[37] tools_4.3.1       gtable_0.3.3     \n\n\nA more elegant approach to manage your packages is to use a dedicated package like renv, which will make it a lot easier to manage your package versions. But this is past the scope of this workshop, just keep in mind it might be something rewarding to look at, if you should start to programm more with R. Instead, let’s look at how to get data into R in the next chapter, so we can actually get to work with it."
  },
  {
    "objectID": "qmd/packages/packages.html#install-packages",
    "href": "qmd/packages/packages.html#install-packages",
    "title": "Packages",
    "section": "",
    "text": "Before we can use packages we have to install them once. Most packages are hosted via the Comprehensive R Archive Network (CRAN), to install a package from there, we can use:\n\ninstall.packages(\"aRtsy\")\n\nBut often packages are only (or as well) provided via GitHub. To install a package from there, use:\n\ndevtools::install_github(\"cutterkom/generativeart\")"
  },
  {
    "objectID": "qmd/packages/packages.html#load-packages",
    "href": "qmd/packages/packages.html#load-packages",
    "title": "Packages",
    "section": "",
    "text": "After installing a package, we have to load it into our R session:\n\n#library(aRtsy)\n\nNow we are free to use it, in this case to generate some artwork:\n\n#set.seed(1)\n#canvas_collatz(colors = colorPalette(\"lava\"))"
  },
  {
    "objectID": "qmd/packages/packages.html#function-conflicts",
    "href": "qmd/packages/packages.html#function-conflicts",
    "title": "Packages",
    "section": "",
    "text": "Expand to learn about dealing with identical function names from different packages\n\n\n\n\n\nOf course it can happen that different packages include functions with the same name. For example, look at the warnings we get when installing and then loading the packages ggplot2 and psych:\n\ninstall.packages(\"ggplot2\")\ninstall.packages(\"psych\")\n\n\nlibrary(ggplot2)\nlibrary(psych)\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n\n\nThere seems to be a function named alpha which is included in both packages (but not the same function, just the same name). The warning message notifies us that the object alpha from ggplot2 is masked, so if we call it, the alpha function from the psych package is used. To solve that quandary, we can use the :: operator. In front we write the package name, and behind it the name of the function we want to use from that package:\n\nggplot2::alpha()\npsych::alpha()"
  },
  {
    "objectID": "qmd/packages/packages.html#deliberate-package-management",
    "href": "qmd/packages/packages.html#deliberate-package-management",
    "title": "Packages",
    "section": "",
    "text": "Expand to learn about managing package versions\n\n\n\n\n\nFinally, a quick note on package management and reproducability of your code. R versions and package versions will change over time, in which case also the output of your code might change. Therefore, it is good practice to save the R version and package versions, so your code stays (kind of) reproducable for a longer period of time. The most straight forward thing to do is to just write down your R-version and the package versions at the top of your script. Call the versions you use with:\n\nsessionInfo()\n\nR version 4.3.1 (2023-06-16)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] psych_2.3.6   ggplot2_3.4.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.3       nlme_3.1-162      cli_3.6.1         knitr_1.43       \n [5] rlang_1.1.1       xfun_0.39         generics_0.1.3    renv_1.0.0       \n [9] jsonlite_1.8.7    glue_1.6.2        colorspace_2.1-0  htmltools_0.5.5  \n[13] scales_1.2.1      fansi_1.0.4       rmarkdown_2.23    grid_4.3.1       \n[17] evaluate_0.21     munsell_0.5.0     tibble_3.2.1      fastmap_1.1.1    \n[21] yaml_2.3.7        lifecycle_1.0.3   compiler_4.3.1    dplyr_1.1.2      \n[25] pkgconfig_2.0.3   rstudioapi_0.15.0 lattice_0.21-8    digest_0.6.32    \n[29] R6_2.5.1          tidyselect_1.2.0  utf8_1.2.3        parallel_4.3.1   \n[33] mnormt_2.1.1      pillar_1.9.0      magrittr_2.0.3    withr_2.5.0      \n[37] tools_4.3.1       gtable_0.3.3     \n\n\nA more elegant approach to manage your packages is to use a dedicated package like renv, which will make it a lot easier to manage your package versions. But this is past the scope of this workshop, just keep in mind it might be something rewarding to look at, if you should start to programm more with R. Instead, let’s look at how to get data into R in the next chapter, so we can actually get to work with it."
  },
  {
    "objectID": "qmd/packages/packages.html#footnotes",
    "href": "qmd/packages/packages.html#footnotes",
    "title": "Packages",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIcons from icons8.de.↩︎\nIcons from icons8.de.↩︎"
  },
  {
    "objectID": "qmd/basics/basics.html",
    "href": "qmd/basics/basics.html",
    "title": "Basic operations",
    "section": "",
    "text": "Let’s take a quick look at the most important basic operations in R. You can also use a cheat sheet to keep an overview during the course.\n\n\nWe can use R as a calculator:\n\n(1 + 2) * 3^2\n2 - 3/log(8)\n\n\n\n\nWe can create objects in R by using the assignment operator &lt;-, which assigns a value to an object:\n\n## Assign the result of 1 + 1 to the object 'result':\nresult &lt;- 1 + 1\nresult\n\n[1] 2\n\n## Assign the result of the comparison to the object 'log_result':\nlog_result &lt;- !(10 &gt; 1)\nlog_result\n\n[1] FALSE\n\n\n\n\n\nThe boolean variables in R are TRUE and FALSE. Comparison operators return either TRUE or FALSE:\n\n1 &lt; 2\n\n[1] TRUE\n\n# But:\n2 &lt; 1\n\n[1] FALSE\n\n\nThese are the comparison operators you will typically use:\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n==\nequal to\n\n\n!=\nnot equal to\n\n\n&lt;=\nless or equal\n\n\n&gt;=\ngreater or equal\n\n\n\n\n\nMainly we will use these logical operation to check which elements in a vector satisfy some requirements:\n\n# Build a vector of numbers ranging from 1 to 10\nvec_num &lt;- 1:10\n\n# Check which of these numbers are smaller than 5\nvec_num &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nThis will become important later on, when we want to subset vectors and data frames to extract only those values that satisfy some requirements we defined.\n\n\n\nWe can invert boolean values by using !:\n\n!TRUE\n\n[1] FALSE\n\n!(1 &gt; 100)\n\n[1] TRUE\n\n!(1:10 != c(1, 2))\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n\nEverything that does something in R is a function. A function call has the form: functionname(argument1 = value, argument2 = value, ...). One basic example for a function is the function that can calculate the square root:\n\nsqrt(4)\n\n[1] 2\n\n\nWe can also assign the name of the function argument to our value. This is clearer, as we don’t rely on the order of the function arguments:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nwill rep 4 10 times. If we swap the arguments, the 10 will be repeat 4 times:\n\nrep(10, 4)\n\n[1] 10 10 10 10\n\n\nBut if we specify which value belongs to which function argument, the order doesn’t matter:\n\nrep(times = 10, x = 4)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nHow do we know which arguments a function has?:\n\n\n\nOne of the most important functions in R is the help-function ?:\n\n?rep\n\nwill open the documentation for the function with the description of its usage, details about the arguments … In the next chapter we will take a very quick look at R’s data types.\n\n\n\n\nLoad the tutoR package and start the exercises about the basic operations by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"basics\", package = \"tutoR\")"
  },
  {
    "objectID": "qmd/basics/basics.html#basic-mathematical-operations",
    "href": "qmd/basics/basics.html#basic-mathematical-operations",
    "title": "Basic operations",
    "section": "",
    "text": "We can use R as a calculator:\n\n(1 + 2) * 3^2\n2 - 3/log(8)"
  },
  {
    "objectID": "qmd/basics/basics.html#assignment-operator",
    "href": "qmd/basics/basics.html#assignment-operator",
    "title": "Basic operations",
    "section": "",
    "text": "We can create objects in R by using the assignment operator &lt;-, which assigns a value to an object:\n\n## Assign the result of 1 + 1 to the object 'result':\nresult &lt;- 1 + 1\nresult\n\n[1] 2\n\n## Assign the result of the comparison to the object 'log_result':\nlog_result &lt;- !(10 &gt; 1)\nlog_result\n\n[1] FALSE"
  },
  {
    "objectID": "qmd/basics/basics.html#comparisons-and-logical-operators",
    "href": "qmd/basics/basics.html#comparisons-and-logical-operators",
    "title": "Basic operations",
    "section": "",
    "text": "The boolean variables in R are TRUE and FALSE. Comparison operators return either TRUE or FALSE:\n\n1 &lt; 2\n\n[1] TRUE\n\n# But:\n2 &lt; 1\n\n[1] FALSE\n\n\nThese are the comparison operators you will typically use:\n\n\n\n\n\nOperator\nDescription\n\n\n\n\n&lt;\nless than\n\n\n&gt;\ngreater than\n\n\n==\nequal to\n\n\n!=\nnot equal to\n\n\n&lt;=\nless or equal\n\n\n&gt;=\ngreater or equal\n\n\n\n\n\nMainly we will use these logical operation to check which elements in a vector satisfy some requirements:\n\n# Build a vector of numbers ranging from 1 to 10\nvec_num &lt;- 1:10\n\n# Check which of these numbers are smaller than 5\nvec_num &lt; 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nThis will become important later on, when we want to subset vectors and data frames to extract only those values that satisfy some requirements we defined."
  },
  {
    "objectID": "qmd/basics/basics.html#section",
    "href": "qmd/basics/basics.html#section",
    "title": "Basic operations",
    "section": "",
    "text": "We can invert boolean values by using !:\n\n!TRUE\n\n[1] FALSE\n\n!(1 &gt; 100)\n\n[1] TRUE\n\n!(1:10 != c(1, 2))\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "qmd/basics/basics.html#functions",
    "href": "qmd/basics/basics.html#functions",
    "title": "Basic operations",
    "section": "",
    "text": "Everything that does something in R is a function. A function call has the form: functionname(argument1 = value, argument2 = value, ...). One basic example for a function is the function that can calculate the square root:\n\nsqrt(4)\n\n[1] 2\n\n\nWe can also assign the name of the function argument to our value. This is clearer, as we don’t rely on the order of the function arguments:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nwill rep 4 10 times. If we swap the arguments, the 10 will be repeat 4 times:\n\nrep(10, 4)\n\n[1] 10 10 10 10\n\n\nBut if we specify which value belongs to which function argument, the order doesn’t matter:\n\nrep(times = 10, x = 4)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nHow do we know which arguments a function has?:"
  },
  {
    "objectID": "qmd/basics/basics.html#help",
    "href": "qmd/basics/basics.html#help",
    "title": "Basic operations",
    "section": "",
    "text": "One of the most important functions in R is the help-function ?:\n\n?rep\n\nwill open the documentation for the function with the description of its usage, details about the arguments … In the next chapter we will take a very quick look at R’s data types."
  },
  {
    "objectID": "qmd/basics/basics.html#exercise",
    "href": "qmd/basics/basics.html#exercise",
    "title": "Basic operations",
    "section": "",
    "text": "Load the tutoR package and start the exercises about the basic operations by typing the following code into your console:\n\n\nlearnr::run_tutorial(name = \"basics\", package = \"tutoR\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to this R workshop!\n\nWhat is R?\n\nR is a popular programming language for data manipulation, statistical data analyses and plotting of data.\nIt is open source, and has a big community, which facilitates the development of additional software packages for multiple different applications, but also makes it easy to get help if you are stuck at a paticular problem.\nThis is one of the reasons why R is great for doing statistical analyses with it - there are packages for almost every use case.\nIt has great tools for making beautiful plots.\nThis is not R specific, but because you can write programs for your specific use cases, it facilitates many workflow related tasks like automation, tracking changes with git, result preperation with markdown/latex and many more.\n\nThere are many reasons to learn R and this workshop will hopefully help you with that.\n\n\nAbout this workshop\nThis workshop will teach you the basics of R. It’s modular structure is meant to support different levels of R expertise and interests: already know the basics and want to learn how to plot? Want to freshen up your R skills and look at specific topics? Or are you new to scientific programming with R and want to follow the course structure?\n\n\n\n\n\n\nUnfold if you want to learn more about advanced content\n\n\n\n\n\nDon’t worry if you don’t finish the whole workshop in time, or the material seems a bit overwhelming. It is designed to provide additional information for self studying and looking up topics of interest (that may come up during the following week, or in general). Advanced explanations and exercises can be found in folded in chunks like this one.\n\n\n\nThe main objective of this workshop is to get you familiar with the basics of programming in R, as it needed for other courses of the Open Research Summer School. To do that, we will repeat and try out the main concepts multiple times, so you get to work with them as much and as from many different perspectives as possible in 3 h.\n\n\n\n\n\n\nCaution\n\n\n\nPlease install the necessary software before the workshop. Of course, feel free to ask by opening a new issue if you run into problems on the way."
  },
  {
    "objectID": "the_big_picture.html",
    "href": "the_big_picture.html",
    "title": "The big picture",
    "section": "",
    "text": "Now that we have completed our set up, let’s dive right into programming with R. In this chapter, we will go through a “mini-project” with very basic data, which follows a possible workflow when working with data in R. We will install and load packages, load data, perform some operations on this data, calculate some summary statistics and plot them. In later chapters, we will go into a little more depth for each topic. If you want to have more in depth information instead of following the whole workflow first, you can also skip this chapter and jump to the chapters and exercises you are interested in. But make sure to do the final exercise, to test you R proficiency in the end.\n\n\nPackages are extensions to the base R you get by default. We already installed our first packages in About this workshop. Let’s keep doing that and install the following package as well:\n\ninstall.packages(\"tidyverse\")\n\nThe tidyverse is a collection of packages following a common philosophy, and facilitate many aspects of coding in R, for example data wrangling and plotting. We will use both functions from base R and from the tidyverse. However, as i personally find them to be easier to understand in many cases, we will use tdiyverse functions a lot in the current chapter, so you can quickly get an overview of what is possible with R.\nJust by installing the packages, we can’t use them. We also have to load them into our R session:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\n\nData is loaded into R so you can work with it. For this chapter, we are going to use the data set babynames, which we can find on the tidytuesday site. You can find it on here.We want to look at the most common name in every year and make a nice plot out of it.\n\nbabynames &lt;- readRDS(\"./raw_data/babynames.rds\")\n\nThe above code will load the data into R and assigning it the name babynames by using the &lt;-. You can see the data popping up in your Environment pane on the upper right.\n\n\n\nNow that we have our data loaded safely into R, we can get an overview with a multitude of commands. One of the most important ones might be View(), which will open the data set excel-style in a new window:\n\nView(babynames)\n\nEspecially for bigger data sets, it might be more feasible to only look at the structure and not the whole data set:\n\nstr(babynames)\n\n'data.frame':   1924665 obs. of  5 variables:\n $ year: num  NA 1880 1880 NA 1880 1880 1880 1880 1880 1880 ...\n $ sex : chr  \"F\" \"F\" \"F\" \"F\" ...\n $ name: chr  \"Mary\" \"Anna\" \"Emma\" \"Elizabeth\" ...\n $ prop: num  0.0724 0.0267 0.0205 0.0199 0.0179 ...\n $ ID  : int  1 2 3 4 5 6 7 8 9 10 ...\n\n\nOn the left we can see the columns of this data.frame, named year, sex, names, n and prop. On the right we see the first values in each column, for example NA, 1980, 1980 etc … in the year-column.\n\n\n\nSadly the data is not complete. The n is missing (ok, i split it up for illustrational purposes). So let’s load it quickly:\n\nbabynames_n &lt;- readRDS(\"./raw_data/babynames_n.rds\")\n\nAnd now merge it:\n\nbabynames_merged &lt;- merge(babynames, babynames_n)\n\nhead(babynames_merged)\n\n  ID year sex      name       prop    n\n1  1   NA   F      Mary 0.07238359 7065\n2  2 1880   F      Anna 0.02667896 2604\n3  3 1880   F      Emma 0.02052149 2003\n4  4   NA   F Elizabeth 0.01986579 1939\n5  5 1880   F    Minnie 0.01788843 1746\n6  6 1880   F  Margaret 0.01616720 1578\n\n\nHold on! The column years seems to include missing values (NA's, see the cell on the top left). It is always a good idea to deal with them before doing any analyses, so let’s do just that:\n\n\n\nThere are multiple ways to deal with missing values. For reasons of simplicity, we will just remove any rows that contain NA's. We can achieve that very easily using a function from the tidyverse (the package collection we installed at the beginning of this chapter):\n\n\nbabynames_merged &lt;- drop_na(babynames_merged)\n\n\n\n\n\nOne very important part of working with data in R is the subsetting of data. This means we select specific values from a data set. Let’s suppose we want to only look at the female names in this data set:\n\n\nbabynames_F &lt;- babynames_merged %&gt;%\n  filter(sex == \"F\")\n\n\n\n\n\nNow, we want to plot the percentages of each name, instead of the propability, because it looks a bit more intuitive. So, let’s build a new column:\n\nbabynames_F$percentage &lt;- babynames_F$prop * 100\n\n\n\n\nNow, the specifics of the next part are not really relevant. However, they can show you how easy it can be to deal with data in R: First, let’s group our data according to year:\n\n\nbabynames_F_grouped &lt;- babynames_F %&gt;%\n  group_by(year)\n\n\nAny operations we now perform are performed for every group. In our case, we want to find the name with the maximum prop in each group:\n\n\nbabynames_F_max &lt;- babynames_F_grouped %&gt;%\n  slice(which.max(percentage))\n\nhead(babynames_F_max)\n\n# A tibble: 6 × 7\n# Groups:   year [6]\n     ID  year sex   name    prop     n percentage\n  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n1     2  1880 F     Anna  0.0267  2604       2.67\n2  2001  1881 F     Mary  0.0700  6919       7.00\n3  3936  1882 F     Mary  0.0704  8148       7.04\n4  6063  1883 F     Mary  0.0667  8012       6.67\n5  8147  1884 F     Mary  0.0670  9217       6.70\n6 10444  1885 F     Mary  0.0643  9128       6.43\n\n\n\nGreat! We now have a data frame containing one row for every year. In it, we find the name most common in that year. As already mentioned, the specifics of these functions are not really relevant for this workshop.\n\n\n\nThis section is more additional and not really necessary for the other workshops. However, i think it is a great way to show you the beauty of plotting in R, so here it goes (make sure you worked on the other concepts first).\nWe will use the package ggplot2 (which is also part of the tidyverse) for plotting our data. It should be mentioned that Base R also has some powerful plotting functions, however, ggplot2 makes it very easy to build complex and beautiful plots.\nA ggplot is constructed from multiple layers, that can be laid over each other using the + operator.\nWe start with the function ggplot(), where we define our data and the x and y aestetics.\n\n\np &lt;- ggplot(\n  data = babynames_F_max,\n  aes(\n    x = year,\n    y = percentage)\n  )\n\nWe can also define different colours for different groups. For example, if we want the bars to get filled with a colour corresponding to the name they are representing, we can do that:\n\np &lt;- ggplot(\n  data = babynames_F_max,\n  aes(\n    x = year,\n    y = percentage,\n    fill = name\n  )\n)\n\nNow that we have defined our aesthetics, we can add a geom-layer. This will make use of the data we have defined in ggplot() and plot some bars for us:\n\np &lt;- p +\n  geom_col()\np\n\n\n\n\nLet’s give the axes some more informative names and a title to the plot:\n\np &lt;- p +\n  ggtitle(\"Most common female name in the United States of America by year\") +\n  xlab(\"Birthyear\") +\n  ylab(\"Percentage of children given that name relative to total births\")\np\n\n\n\n\nFinally, to style the plot a bit, let’s add a predefined theme and a color palette:\n\np +\n  theme_bw() +\n  scale_fill_brewer(palette = \"Set3\")\n\n\n\n\n\n\n\n\nIn this tutorial we learned, that R is a flexible tool for editing and plotting data. Of course, we barely scratched the surface. Therefore, we want to dive a bit deeper into each step. Either follow the course, or navigate to the chapters you are most interested in.\nTest link to basics"
  },
  {
    "objectID": "the_big_picture.html#packages",
    "href": "the_big_picture.html#packages",
    "title": "The big picture",
    "section": "",
    "text": "Packages are extensions to the base R you get by default. We already installed our first packages in About this workshop. Let’s keep doing that and install the following package as well:\n\ninstall.packages(\"tidyverse\")\n\nThe tidyverse is a collection of packages following a common philosophy, and facilitate many aspects of coding in R, for example data wrangling and plotting. We will use both functions from base R and from the tidyverse. However, as i personally find them to be easier to understand in many cases, we will use tdiyverse functions a lot in the current chapter, so you can quickly get an overview of what is possible with R.\nJust by installing the packages, we can’t use them. We also have to load them into our R session:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "the_big_picture.html#load-data",
    "href": "the_big_picture.html#load-data",
    "title": "The big picture",
    "section": "",
    "text": "Data is loaded into R so you can work with it. For this chapter, we are going to use the data set babynames, which we can find on the tidytuesday site. You can find it on here.We want to look at the most common name in every year and make a nice plot out of it.\n\nbabynames &lt;- readRDS(\"./raw_data/babynames.rds\")\n\nThe above code will load the data into R and assigning it the name babynames by using the &lt;-. You can see the data popping up in your Environment pane on the upper right."
  },
  {
    "objectID": "the_big_picture.html#take-a-look",
    "href": "the_big_picture.html#take-a-look",
    "title": "The big picture",
    "section": "",
    "text": "Now that we have our data loaded safely into R, we can get an overview with a multitude of commands. One of the most important ones might be View(), which will open the data set excel-style in a new window:\n\nView(babynames)\n\nEspecially for bigger data sets, it might be more feasible to only look at the structure and not the whole data set:\n\nstr(babynames)\n\n'data.frame':   1924665 obs. of  5 variables:\n $ year: num  NA 1880 1880 NA 1880 1880 1880 1880 1880 1880 ...\n $ sex : chr  \"F\" \"F\" \"F\" \"F\" ...\n $ name: chr  \"Mary\" \"Anna\" \"Emma\" \"Elizabeth\" ...\n $ prop: num  0.0724 0.0267 0.0205 0.0199 0.0179 ...\n $ ID  : int  1 2 3 4 5 6 7 8 9 10 ...\n\n\nOn the left we can see the columns of this data.frame, named year, sex, names, n and prop. On the right we see the first values in each column, for example NA, 1980, 1980 etc … in the year-column."
  },
  {
    "objectID": "the_big_picture.html#merging",
    "href": "the_big_picture.html#merging",
    "title": "The big picture",
    "section": "",
    "text": "Sadly the data is not complete. The n is missing (ok, i split it up for illustrational purposes). So let’s load it quickly:\n\nbabynames_n &lt;- readRDS(\"./raw_data/babynames_n.rds\")\n\nAnd now merge it:\n\nbabynames_merged &lt;- merge(babynames, babynames_n)\n\nhead(babynames_merged)\n\n  ID year sex      name       prop    n\n1  1   NA   F      Mary 0.07238359 7065\n2  2 1880   F      Anna 0.02667896 2604\n3  3 1880   F      Emma 0.02052149 2003\n4  4   NA   F Elizabeth 0.01986579 1939\n5  5 1880   F    Minnie 0.01788843 1746\n6  6 1880   F  Margaret 0.01616720 1578\n\n\nHold on! The column years seems to include missing values (NA's, see the cell on the top left). It is always a good idea to deal with them before doing any analyses, so let’s do just that:"
  },
  {
    "objectID": "the_big_picture.html#missings",
    "href": "the_big_picture.html#missings",
    "title": "The big picture",
    "section": "",
    "text": "There are multiple ways to deal with missing values. For reasons of simplicity, we will just remove any rows that contain NA's. We can achieve that very easily using a function from the tidyverse (the package collection we installed at the beginning of this chapter):\n\n\nbabynames_merged &lt;- drop_na(babynames_merged)"
  },
  {
    "objectID": "the_big_picture.html#subsetting-data",
    "href": "the_big_picture.html#subsetting-data",
    "title": "The big picture",
    "section": "",
    "text": "One very important part of working with data in R is the subsetting of data. This means we select specific values from a data set. Let’s suppose we want to only look at the female names in this data set:\n\n\nbabynames_F &lt;- babynames_merged %&gt;%\n  filter(sex == \"F\")"
  },
  {
    "objectID": "the_big_picture.html#adding-a-new-column",
    "href": "the_big_picture.html#adding-a-new-column",
    "title": "The big picture",
    "section": "",
    "text": "Now, we want to plot the percentages of each name, instead of the propability, because it looks a bit more intuitive. So, let’s build a new column:\n\nbabynames_F$percentage &lt;- babynames_F$prop * 100"
  },
  {
    "objectID": "the_big_picture.html#some-additional-summary-statistics",
    "href": "the_big_picture.html#some-additional-summary-statistics",
    "title": "The big picture",
    "section": "",
    "text": "Now, the specifics of the next part are not really relevant. However, they can show you how easy it can be to deal with data in R: First, let’s group our data according to year:\n\n\nbabynames_F_grouped &lt;- babynames_F %&gt;%\n  group_by(year)\n\n\nAny operations we now perform are performed for every group. In our case, we want to find the name with the maximum prop in each group:\n\n\nbabynames_F_max &lt;- babynames_F_grouped %&gt;%\n  slice(which.max(percentage))\n\nhead(babynames_F_max)\n\n# A tibble: 6 × 7\n# Groups:   year [6]\n     ID  year sex   name    prop     n percentage\n  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n1     2  1880 F     Anna  0.0267  2604       2.67\n2  2001  1881 F     Mary  0.0700  6919       7.00\n3  3936  1882 F     Mary  0.0704  8148       7.04\n4  6063  1883 F     Mary  0.0667  8012       6.67\n5  8147  1884 F     Mary  0.0670  9217       6.70\n6 10444  1885 F     Mary  0.0643  9128       6.43\n\n\n\nGreat! We now have a data frame containing one row for every year. In it, we find the name most common in that year. As already mentioned, the specifics of these functions are not really relevant for this workshop."
  },
  {
    "objectID": "the_big_picture.html#plot-the-data",
    "href": "the_big_picture.html#plot-the-data",
    "title": "The big picture",
    "section": "",
    "text": "This section is more additional and not really necessary for the other workshops. However, i think it is a great way to show you the beauty of plotting in R, so here it goes (make sure you worked on the other concepts first).\nWe will use the package ggplot2 (which is also part of the tidyverse) for plotting our data. It should be mentioned that Base R also has some powerful plotting functions, however, ggplot2 makes it very easy to build complex and beautiful plots.\nA ggplot is constructed from multiple layers, that can be laid over each other using the + operator.\nWe start with the function ggplot(), where we define our data and the x and y aestetics.\n\n\np &lt;- ggplot(\n  data = babynames_F_max,\n  aes(\n    x = year,\n    y = percentage)\n  )\n\nWe can also define different colours for different groups. For example, if we want the bars to get filled with a colour corresponding to the name they are representing, we can do that:\n\np &lt;- ggplot(\n  data = babynames_F_max,\n  aes(\n    x = year,\n    y = percentage,\n    fill = name\n  )\n)\n\nNow that we have defined our aesthetics, we can add a geom-layer. This will make use of the data we have defined in ggplot() and plot some bars for us:\n\np &lt;- p +\n  geom_col()\np\n\n\n\n\nLet’s give the axes some more informative names and a title to the plot:\n\np &lt;- p +\n  ggtitle(\"Most common female name in the United States of America by year\") +\n  xlab(\"Birthyear\") +\n  ylab(\"Percentage of children given that name relative to total births\")\np\n\n\n\n\nFinally, to style the plot a bit, let’s add a predefined theme and a color palette:\n\np +\n  theme_bw() +\n  scale_fill_brewer(palette = \"Set3\")"
  },
  {
    "objectID": "the_big_picture.html#conclusion",
    "href": "the_big_picture.html#conclusion",
    "title": "The big picture",
    "section": "",
    "text": "In this tutorial we learned, that R is a flexible tool for editing and plotting data. Of course, we barely scratched the surface. Therefore, we want to dive a bit deeper into each step. Either follow the course, or navigate to the chapters you are most interested in.\nTest link to basics"
  }
]