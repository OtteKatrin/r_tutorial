# Merging
Suppose we want to look at the winners by continent. In this case, we will have to add a list assigning each Nationality a continent. We can easily find such a list online, for example at [ourworldindata.org](https://ourworldindata.org/grapher/continents-according-to-our-world-in-data).
I have already [downloaded](https://github.com/nickhaf/r_tutorial/tree/main/raw_data) the `.csv`, so let's try to load it into R:

```{r}
continents <- read.csv(file = "./raw_data/continents.csv")

head(continents)
```
Hmm that looks weird. If we take a look at the file by opening it in a text editor, we can see that the values are seperated by `;`. 
So let's call the help for `read.csv()`:
```{r}
?read.csv
```
The `sep` argument specifies that the seperator needs to be a white space (meaning tabs, spaces ... - look at the details).  
So, we can do the following:
```{r}
continents <- read.csv(file = "./raw_data/continents.csv", 
                       sep = ";")

head(continents)
```

This looks better! Now we can merge both data sets, so we can actually work with them.
To merge two data frames that include information that belongs together, we need a common column, on which we can merge them. 
In our case, this is the column containing the country, but they are named differently. No problem, we can define which columns should be taken from which data frame for merging:


# Merging data frames

```{r}
winners_continents <- merge(x = winners,
                             y = continents,
                             by.x = "Nationality", 
                             by.y = "Entity")
head(winners_continents)
```
Great! Now the information that belongs together is stored together.  
If the merging column(s) had the same name in both data sets, we wouldn't have to specify them at all, the function can compare the column names automatically. 

# New columns
Adding new columns to a data frame is pretty straight forward. We just define the column name, and then assign it some input.
For example, we could be interested in calculating the seconds each person needed to finish, and add that as a new column:

```{r}
winners_continents$Seconds_total <- winners_continents$Hours * 60^2 + winners_continents$Minutes * 60 + winners_continents$Seconds
head(winners_continents)
```

Or, using the `tidyverse` with the help of `mutate()`:

::: tidy
```{r, message = FALSE}
winners_continents <- winners_continents %>%
  mutate(Minutes_total = winners_continents$Hours * 60 + winners_continents$Minutes * winners_continents$Seconds / 60)
head(winners_continents)
```
:::

Hold on! Both new columns seem to have missing values, which is an important concept which we haven't talked about yet. So let's do that quickly, and then merge!

# Missing values
Missing values are denoted in R by `NA` (or `NaN` in some cases).
The pretty strongly nullify a calculation - if one missing value is found somewhere along the line, the result will also be `NA` (if not specified otherwise):
```{r}
sum(c(4,5,NA))
```
That's why our newly build columns include `NAs`: The column `Hours` already had some, and by adding with `NAs` we just produced new ones. 

To check if values are `NA`, we can use `is.na()`:
```{r}
is.na(winners_continents$Hours)
```
Some `TRUEs`, so there are missing values here. Let's count them (Summing an [logical vector](https://nickhaf.github.io/r_tutorial/basics.html#comparisons-and-logical-operators) counts the number of `TRUE` values.):
```{r}
sum(is.na(winners_continents$Hours))
```
We seem to have `5` missings in this column. 
There are multiple different ways to deal with missings. For this tutorial, we just remove cases with missing values on the `Hours` variable:
```{r}
winners_continents_na <- winners_continents[!is.na(winners_continents$Hours), ]
```
What happens here? 
Like always when filtering specific rows, we define a logical vector, which has a `TRUE` for all rows that have a missing on `ID` and a `FALSE` for all others (by using the `!` operator, which inverts the boolean values - otherwise we would extract all rows with missing values in the `ID` column):

```{r}
!is.na(winners$ID)
```

We also assign a new name to the resulting data frame. 

# ifelse
We can also add new values conditionally, for example by using the `ifelse()` function. 
For example, we could add a column with the continent of each 

```{r}


```

::: tidy
```{r}
persons <- persons %>%
  mutate(big5_extra_dichotomous = ifelse(test = persons$big5_neuro >= 5/2,
                                         yes = "high",
                                         no = "low")
  )
persons
```
:::

