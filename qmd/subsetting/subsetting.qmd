---
title: "Subsetting"
---

```{r, echo = FALSE}
source(here::here("output_hook.R"))
athletes <- readRDS(here::here("raw_data", "athletes.rds"))
```

Subsetting is extracting smaller sets of data from a bigger set. For example, we can extract specific rows from a data frame, or specific values from a vector. Let's take a look at how that is achieved in R:

## Data frames

In `R` we use square brackets `[,]` to extract specific rows and columns.

### Rows

In front of the `,` we write the **rows** we want to extract:

```{r, output.lines=4}
# Extract the first and the fourth row
athletes[c(1, 4), ]
```

### Columns

Behind it the **columns**:

```{r, output.lines=4}
# Extract the second and the fourth column:
athletes[, c(2, 4)]

# Extract the columns by name:
athletes[, c("Year", "Sport")]

# Or only the column Year (and turn it into a vector right away):
athletes$Year
```

::: callout-tip
Always use column names instead of position if possible. This way, your code will still work if the column position changes.
:::

### Rows & Columns

And of course we can combine both calls:

```{r, output.lines=4}
athletes[c(1, 4), c(2, 4)]

athletes[c(1, 4), c("Year", "Sport")]
```

We can also use Boolean values (every row/column must get a value here, so we extract the first 100 rows by repeating `TRUE` 100 times, and than add `FALSE` for the remaining rows):

```{r}
str(athletes[c(rep(TRUE, 100), rep(FALSE, 271016)), ])
```

### Conditional filtering

Now the stuff we looked at in [logical operators](../basics/basics.qmd#comparisons-and-logical-operators) comes in handy! We can filter rows which match some condition. For example, we might want to look at all athletes from Germany:

```{r, output.lines=4}
athletes[athletes$Team == "Germany", ]
```

::: {.callout-note collapse="true"}
## Unfold if you want to take a closer look at what is happening here

Take a close look at the comparison before the `,`:

```{r, output.lines=4}
athletes$Team == "Germany"
```

`athletes$Team` is a vector, so comparing its values to a specified value yields a logical vector with the respective `TRUE` and `FALSE` values. We can insert this logical vector in front of the `,` to extract all rows corresponding to that condition.
:::

If we want to extract multiple nationalities at once, we need the `%in%` operator:

```{r, output.lines=4}
athletes[athletes$Team %in% c("Kenya", "Norway"), ]
```

By the way, if we want to save our extracted data frame, we can assign it a new name (otherwise it will only get printed into the console, but we can't go on working with it):

```{r, output.lines=4}
athletes_team <- athletes[athletes$Team %in% c("Kenya", "Norway"), ]
athletes_team
```

We can also combine multiple logical vectors using `&` ("and") and `|` ("or"). For example, we might want to look at all german athletes before the year 2000:

```{r, output.lines=4}
athletes[athletes$Team == "Germany" & athletes$Year < 2000, ]
```

Or at all judo athletes weighting over 100 or under 50 kg:

```{r, output.lines=4}
athletes[(athletes$Sport == "Judo") & (athletes$Weight > 100 | athletes$Weight < 50) , ]
```

Hmm, that looks a bit weird. Some rows only contain `NA` values. That's because there are [missing values](../missings/missings.qmd) in the `Weight` column. We will look at that closer in the [missings chapter](../missings/missings.qmd) and ignore that problem for now.

In the long run, always having to define the data frame multiple time in each row can become a bit annoying and clutters the code. Also the missings problem ... Enter, the `filter()` function:

#### Rows: Tidyverse

::: tidy
```{r, message = FALSE, output.lines=4}
library(tidyverse)

athletes %>% 
  filter(Sport == "Judo", (Weight > 100 | Weight < 50))
```
:::

Note how we can just write our conditions without connecting them with `&` (`filter()` does that automatically for us). Also, we don't have to put the column names into `""`, because `filter()` knows that this are column names of the `athletes` data frame, which makes coding a bit more pleasant. And finally, missing rows are automatically removed, which makes sense in most cases!

#### Columns: Tidyverse

For extracting columns, we need `select()`:

::: tidy
```{r, output.lines=4}
athletes %>%
  select(Year, Sport)
```
:::

## Vectors

Finally, let's take a quick look at how to extract elements from a vector, which shouldn't be a problem after already dealing with data frames. It's pretty straight forward: we just put the position of the element we want to extract behind the vector in square brackets (without a `,`, as we only have a one dimensional object). Let's quickly define a vector for illustration:

```{r}
vec_sport <- athletes$Sport # remember: `$` returns a vector
```

And look at the second element:

```{r}
vec_sport[2]
```

Of course we can also do that for multiple elements:

```{r}
vec_sport[c(2, 3, 4)]
## Or, less to write:
vec_sport[2:4]
```

Another way would be to provide a logical vector, which defines for each position if we want to extract the element or not (like we already did for data frames):

```{r, output.lines=4}
vec_sport[c(rep(TRUE, 100), rep(FALSE, 65))]
```
